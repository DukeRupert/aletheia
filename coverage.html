
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dukerupert/aletheia/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/dukerupert/aletheia/internal/ai/ai.go (0.0%)</option>
				
				<option value="file2">github.com/dukerupert/aletheia/internal/ai/claude.go (0.0%)</option>
				
				<option value="file3">github.com/dukerupert/aletheia/internal/ai/mock.go (0.0%)</option>
				
				<option value="file4">github.com/dukerupert/aletheia/internal/auth/password.go (85.7%)</option>
				
				<option value="file5">github.com/dukerupert/aletheia/internal/auth/tokens.go (0.0%)</option>
				
				<option value="file6">github.com/dukerupert/aletheia/internal/config/config.go (0.0%)</option>
				
				<option value="file7">github.com/dukerupert/aletheia/internal/database/db.go (0.0%)</option>
				
				<option value="file8">github.com/dukerupert/aletheia/internal/database/detected_violations.sql.go (0.0%)</option>
				
				<option value="file9">github.com/dukerupert/aletheia/internal/database/inspections.sql.go (0.0%)</option>
				
				<option value="file10">github.com/dukerupert/aletheia/internal/database/models.go (0.0%)</option>
				
				<option value="file11">github.com/dukerupert/aletheia/internal/database/organization_members.sql.go (0.0%)</option>
				
				<option value="file12">github.com/dukerupert/aletheia/internal/database/organizations.sql.go (0.0%)</option>
				
				<option value="file13">github.com/dukerupert/aletheia/internal/database/photos.sql.go (0.0%)</option>
				
				<option value="file14">github.com/dukerupert/aletheia/internal/database/projects.sql.go (0.0%)</option>
				
				<option value="file15">github.com/dukerupert/aletheia/internal/database/reports.sql.go (0.0%)</option>
				
				<option value="file16">github.com/dukerupert/aletheia/internal/database/safety_codes.sql.go (0.0%)</option>
				
				<option value="file17">github.com/dukerupert/aletheia/internal/database/sessions.sql.go (0.0%)</option>
				
				<option value="file18">github.com/dukerupert/aletheia/internal/database/users.sql.go (0.0%)</option>
				
				<option value="file19">github.com/dukerupert/aletheia/internal/email/email.go (0.0%)</option>
				
				<option value="file20">github.com/dukerupert/aletheia/internal/handlers/auth.go (68.3%)</option>
				
				<option value="file21">github.com/dukerupert/aletheia/internal/handlers/helpers.go (100.0%)</option>
				
				<option value="file22">github.com/dukerupert/aletheia/internal/handlers/inspection.go (64.2%)</option>
				
				<option value="file23">github.com/dukerupert/aletheia/internal/handlers/organization.go (63.6%)</option>
				
				<option value="file24">github.com/dukerupert/aletheia/internal/handlers/project.go (68.2%)</option>
				
				<option value="file25">github.com/dukerupert/aletheia/internal/handlers/safety_code.go (0.0%)</option>
				
				<option value="file26">github.com/dukerupert/aletheia/internal/handlers/upload.go (49.7%)</option>
				
				<option value="file27">github.com/dukerupert/aletheia/internal/session/middleware.go (0.0%)</option>
				
				<option value="file28">github.com/dukerupert/aletheia/internal/session/session.go (85.7%)</option>
				
				<option value="file29">github.com/dukerupert/aletheia/internal/storage/s3.go (90.5%)</option>
				
				<option value="file30">github.com/dukerupert/aletheia/internal/storage/storage.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dukerupert/aletheia/internal/config"
        "github.com/dukerupert/aletheia/internal/email"
        "github.com/dukerupert/aletheia/internal/handlers"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/dukerupert/aletheia/internal/storage"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Configure logger
        <span class="cov0" title="0">logger := slog.New(cfg.GetLogger())
        slog.SetDefault(logger)
        logger.Debug("logger initialized", slog.String("level", cfg.Logger.Level.String()))

        // Create pool configuration
        connString := cfg.GetConnectionString()
        logger.Debug("connecting to database", slog.String("url", connString))

        // Parse the connection string and create pool config
        poolConfig, err := pgxpool.ParseConfig(connString)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Configure pool settings (optional but recommended)
        <span class="cov0" title="0">poolConfig.MaxConns = 25                      // Maximum connections in pool
        poolConfig.MinConns = 5                       // Minimum idle connections
        poolConfig.MaxConnLifetime = time.Hour        // Max lifetime of a connection
        poolConfig.MaxConnIdleTime = time.Minute * 30 // Max idle time before closing
        poolConfig.HealthCheckPeriod = time.Minute    // How often to check connection health

        // Create the connection pool
        pool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        // Verify connection
        if err := pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">logger.Info("database connection pool established")

        // Initialize storage service (configured via STORAGE_PROVIDER env var)
        fileStorage, err := storage.NewFileStorage(context.Background(), logger, storage.StorageConfig{
                Provider:  cfg.Storage.Provider,
                LocalPath: cfg.Storage.LocalPath,
                LocalURL:  cfg.Storage.LocalURL,
                S3Bucket:  cfg.Storage.S3Bucket,
                S3Region:  cfg.Storage.S3Region,
                S3BaseURL: cfg.Storage.S3BaseURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Initialize email service (configured via EMAIL_PROVIDER env var)
        <span class="cov0" title="0">emailService := email.NewEmailService(logger, email.EmailConfig{
                Provider:        cfg.Email.Provider,
                PostmarkToken:   cfg.Email.PostmarkToken,
                PostmarkAccount: cfg.Email.PostmarkAccount,
                FromAddress:     cfg.Email.FromAddress,
                FromName:        cfg.Email.FromName,
                VerifyBaseURL:   cfg.Email.VerifyBaseURL,
        })
        logger.Info("email service initialized", slog.String("provider", cfg.Email.Provider))

        e := echo.New()
        e.GET("/", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.String(http.StatusOK, "Hello, World!")
        }</span>)

        // Serve static files from uploads directory
        <span class="cov0" title="0">e.Static("/uploads", "./uploads")

        // Initialize handlers
        uploadHandler := handlers.NewUploadHandler(fileStorage, pool, logger)
        authHandler := handlers.NewAuthHandler(pool, logger, emailService)
        orgHandler := handlers.NewOrganizationHandler(pool, logger)
        projectHandler := handlers.NewProjectHandler(pool, logger)
        inspectionHandler := handlers.NewInspectionHandler(pool, logger)
        safetyCodeHandler := handlers.NewSafetyCodeHandler(pool, logger)

        // Public routes
        e.POST("/api/auth/register", authHandler.Register)
        e.POST("/api/auth/login", authHandler.Login)
        e.POST("/api/auth/verify-email", authHandler.VerifyEmail)
        e.POST("/api/auth/resend-verification", authHandler.ResendVerification)
        e.POST("/api/auth/request-password-reset", authHandler.RequestPasswordReset)
        e.POST("/api/auth/verify-reset-token", authHandler.VerifyResetToken)
        e.POST("/api/auth/reset-password", authHandler.ResetPassword)

        // Protected routes (require session)
        protected := e.Group("/api")
        protected.Use(session.SessionMiddleware(pool))
        protected.POST("/upload", uploadHandler.UploadImage)
        protected.POST("/auth/logout", authHandler.Logout)
        protected.GET("/auth/me", authHandler.Me)
        protected.PUT("/auth/profile", authHandler.UpdateProfile)

        // Organization routes
        protected.POST("/organizations", orgHandler.CreateOrganization)
        protected.GET("/organizations", orgHandler.ListOrganizations)
        protected.GET("/organizations/:id", orgHandler.GetOrganization)
        protected.PUT("/organizations/:id", orgHandler.UpdateOrganization)
        protected.DELETE("/organizations/:id", orgHandler.DeleteOrganization)

        // Organization member routes
        protected.GET("/organizations/:id/members", orgHandler.ListOrganizationMembers)
        protected.POST("/organizations/:id/members", orgHandler.AddOrganizationMember)
        protected.PUT("/organizations/:id/members/:memberId", orgHandler.UpdateOrganizationMember)
        protected.DELETE("/organizations/:id/members/:memberId", orgHandler.RemoveOrganizationMember)

        // Project routes
        protected.POST("/projects", projectHandler.CreateProject)
        protected.GET("/projects/:id", projectHandler.GetProject)
        protected.GET("/organizations/:orgId/projects", projectHandler.ListProjects)
        protected.PUT("/projects/:id", projectHandler.UpdateProject)
        protected.DELETE("/projects/:id", projectHandler.DeleteProject)

        // Inspection routes
        protected.POST("/inspections", inspectionHandler.CreateInspection)
        protected.GET("/inspections/:id", inspectionHandler.GetInspection)
        protected.GET("/projects/:projectId/inspections", inspectionHandler.ListInspections)
        protected.PUT("/inspections/:id/status", inspectionHandler.UpdateInspectionStatus)

        // Photo routes
        protected.GET("/inspections/:inspectionId/photos", uploadHandler.ListPhotos)
        protected.GET("/photos/:id", uploadHandler.GetPhoto)
        protected.DELETE("/photos/:id", uploadHandler.DeletePhoto)

        // Safety code routes
        protected.POST("/safety-codes", safetyCodeHandler.CreateSafetyCode)
        protected.GET("/safety-codes", safetyCodeHandler.ListSafetyCodes)
        protected.GET("/safety-codes/:id", safetyCodeHandler.GetSafetyCode)
        protected.PUT("/safety-codes/:id", safetyCodeHandler.UpdateSafetyCode)
        protected.DELETE("/safety-codes/:id", safetyCodeHandler.DeleteSafetyCode)

        e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
                LogStatus:   true,
                LogURI:      true,
                LogError:    true,
                HandleError: true, // forwards error to the global error handler, so it can decide appropriate status code
                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error </span><span class="cov0" title="0">{
                        if v.Error == nil </span><span class="cov0" title="0">{
                                logger.LogAttrs(context.Background(), slog.LevelInfo, "REQUEST",
                                        slog.String("uri", v.URI),
                                        slog.Int("status", v.Status),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                logger.LogAttrs(context.Background(), slog.LevelError, "REQUEST_ERROR",
                                        slog.String("uri", v.URI),
                                        slog.Int("status", v.Status),
                                        slog.String("err", v.Error.Error()),
                                )
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }))

        // Start server in a goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                logger.Info("starting server", slog.String("address", ":1323"))
                if err := e.Start(":1323"); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Error("server error", slog.String("err", err.Error()))
                        os.Exit(1)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
        &lt;-quit

        logger.Info("shutting down server...")

        // Create shutdown context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // Shutdown Echo server
        if err := e.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("server forced to shutdown", slog.String("err", err.Error()))
        }</span>

        // Close database pool
        <span class="cov0" title="0">pool.Close()
        logger.Info("database pool closed")

        logger.Info("server exited gracefully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ai

import (
        "context"
        "log/slog"
)

// AIService defines the interface for AI vision processing services
type AIService interface {
        // AnalyzePhoto analyzes a photo for safety violations
        // Returns a list of detected violations with their descriptions, severity, and confidence
        AnalyzePhoto(ctx context.Context, request AnalysisRequest) (*AnalysisResponse, error)
}

// AnalysisRequest contains the data needed for photo analysis
type AnalysisRequest struct {
        // ImageData is the raw image bytes
        ImageData []byte
        // ImageURL is an alternative to ImageData - provide either ImageData or ImageURL
        ImageURL string
        // SafetyCodes is the list of safety codes to check against
        SafetyCodes []SafetyCodeContext
        // InspectionContext provides additional context about the inspection
        InspectionContext string
}

// SafetyCodeContext provides context about a safety code for the AI
type SafetyCodeContext struct {
        Code        string
        Description string
        Country     string
}

// AnalysisResponse contains the results of the AI analysis
type AnalysisResponse struct {
        // Violations is the list of detected safety violations
        Violations []DetectedViolation
        // AnalysisDetails contains additional information about the analysis
        AnalysisDetails string
        // TokensUsed tracks API usage (if applicable)
        TokensUsed int
}

// DetectedViolation represents a safety violation detected by the AI
type DetectedViolation struct {
        // SafetyCodeID is the ID of the safety code that was violated (if matched)
        SafetyCodeID string
        // SafetyCode is the code identifier (e.g., "OSHA 1926.501")
        SafetyCode string
        // Description is the AI's description of the violation
        Description string
        // Severity indicates how serious the violation is
        Severity ViolationSeverity
        // Confidence is the AI's confidence in this detection (0.0 - 1.0)
        Confidence float64
        // Location describes where in the image the violation was detected
        Location string
}

// ViolationSeverity represents the severity level of a violation
type ViolationSeverity string

const (
        SeverityCritical ViolationSeverity = "critical"
        SeverityHigh     ViolationSeverity = "high"
        SeverityMedium   ViolationSeverity = "medium"
        SeverityLow      ViolationSeverity = "low"
)

// AIConfig holds configuration for AI services
type AIConfig struct {
        Provider string // "mock", "claude", "openai", etc.

        // Claude/Anthropic configuration
        ClaudeAPIKey string
        ClaudeModel  string // e.g., "claude-3-5-sonnet-20241022"

        // OpenAI configuration (for future use)
        OpenAIAPIKey string
        OpenAIModel  string

        // Common settings
        MaxTokens   int
        Temperature float64
}

// NewAIService creates an AI service based on the provider configuration
func NewAIService(logger *slog.Logger, config AIConfig) AIService <span class="cov0" title="0">{
        switch config.Provider </span>{
        case "claude":<span class="cov0" title="0">
                return newClaudeService(logger, config)</span>
        default:<span class="cov0" title="0">
                return newMockAIService(logger)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ai

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log/slog"
        "strings"

        "github.com/anthropics/anthropic-sdk-go"
        "github.com/anthropics/anthropic-sdk-go/option"
)

// claudeService implements AIService using Claude (Anthropic)
type claudeService struct {
        client      *anthropic.Client
        logger      *slog.Logger
        model       string
        maxTokens   int
        temperature float64
}

// newClaudeService creates a new Claude AI service
func newClaudeService(logger *slog.Logger, config AIConfig) *claudeService <span class="cov0" title="0">{
        client := anthropic.NewClient(
                option.WithAPIKey(config.ClaudeAPIKey),
        )

        return &amp;claudeService{
                client:      &amp;client,
                logger:      logger,
                model:       config.ClaudeModel,
                maxTokens:   config.MaxTokens,
                temperature: config.Temperature,
        }
}</span>

// AnalyzePhoto analyzes a photo for safety violations using Claude's vision API
func (s *claudeService) AnalyzePhoto(ctx context.Context, request AnalysisRequest) (*AnalysisResponse, error) <span class="cov0" title="0">{
        s.logger.Info("analyzing photo with Claude",
                slog.String("model", s.model),
                slog.Int("safety_codes_count", len(request.SafetyCodes)))

        // Build the system prompt with safety code context
        systemPrompt := s.buildSystemPrompt(request.SafetyCodes)

        // Build the user prompt
        userPrompt := s.buildUserPrompt(request.InspectionContext)

        // Prepare image content
        if len(request.ImageData) == 0 &amp;&amp; request.ImageURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("either ImageData or ImageURL must be provided")
        }</span>

        <span class="cov0" title="0">if request.ImageURL != "" </span><span class="cov0" title="0">{
                // Use image URL (not directly supported by Claude SDK, would need to download first)
                return nil, fmt.Errorf("image URL not yet supported - please provide ImageData")
        }</span>

        // Use image data - encode as base64
        <span class="cov0" title="0">base64Image := base64.StdEncoding.EncodeToString(request.ImageData)

        // Determine media type (assume JPEG for now, could be enhanced)
        mediaType := "image/jpeg"

        // Create the message with vision
        message, err := s.client.Messages.New(ctx, anthropic.MessageNewParams{
                Model:     anthropic.Model(s.model),
                MaxTokens: int64(s.maxTokens),
                System: []anthropic.TextBlockParam{
                        {
                                Text: systemPrompt,
                        },
                },
                Messages: []anthropic.MessageParam{
                        anthropic.NewUserMessage(
                                anthropic.NewTextBlock(userPrompt),
                                anthropic.NewImageBlockBase64(mediaType, base64Image),
                        ),
                },
                Temperature: anthropic.Float(s.temperature),
        })

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to analyze photo with Claude",
                        slog.String("error", err.Error()))
                return nil, fmt.Errorf("failed to analyze photo: %w", err)
        }</span>

        // Extract text response
        <span class="cov0" title="0">var responseText string
        for _, content := range message.Content </span><span class="cov0" title="0">{
                if content.Type == "text" </span><span class="cov0" title="0">{
                        responseText += content.Text
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Claude analysis complete",
                slog.Int("input_tokens", int(message.Usage.InputTokens)),
                slog.Int("output_tokens", int(message.Usage.OutputTokens)))

        // Parse the response into violations
        violations, analysisDetails := s.parseClaudeResponse(responseText, request.SafetyCodes)

        return &amp;AnalysisResponse{
                Violations:      violations,
                AnalysisDetails: analysisDetails,
                TokensUsed:      int(message.Usage.InputTokens + message.Usage.OutputTokens),
        }, nil</span>
}

// buildSystemPrompt creates the system prompt with safety code context
func (s *claudeService) buildSystemPrompt(safetyCodes []SafetyCodeContext) string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("You are an expert construction safety inspector AI. Your task is to analyze construction site photos and identify potential safety violations.\n\n")
        sb.WriteString("You have deep knowledge of construction safety standards including OSHA regulations and can identify hazards such as:\n")
        sb.WriteString("- Fall protection issues (missing guardrails, improper harness use, etc.)\n")
        sb.WriteString("- Personal protective equipment violations (missing hard hats, safety glasses, etc.)\n")
        sb.WriteString("- Scaffolding and ladder safety issues\n")
        sb.WriteString("- Electrical hazards\n")
        sb.WriteString("- Excavation and trench hazards\n")
        sb.WriteString("- Equipment safety issues\n")
        sb.WriteString("- Housekeeping and general site safety\n\n")

        if len(safetyCodes) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("Focus on violations related to these safety codes:\n\n")
                for _, code := range safetyCodes </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("- %s: %s\n", code.Code, code.Description))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        <span class="cov0" title="0">sb.WriteString("For each violation you identify, provide:\n")
        sb.WriteString("1. The relevant safety code (if applicable)\n")
        sb.WriteString("2. A clear description of what violation you observed\n")
        sb.WriteString("3. Severity level: critical, high, medium, or low\n")
        sb.WriteString("4. Your confidence level (0.0 to 1.0)\n")
        sb.WriteString("5. Location in the image where the violation appears\n\n")
        sb.WriteString("Respond ONLY with a JSON array of violations. Each violation should be a JSON object with these fields:\n")
        sb.WriteString(`{"safety_code": "OSHA X", "description": "...", "severity": "high", "confidence": 0.85, "location": "..."}`)
        sb.WriteString("\n\nIf no violations are found, return an empty array [].")

        return sb.String()</span>
}

// buildUserPrompt creates the user prompt with inspection context
func (s *claudeService) buildUserPrompt(inspectionContext string) string <span class="cov0" title="0">{
        prompt := "Please analyze this construction site photo for safety violations."

        if inspectionContext != "" </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf("\n\nInspection Context: %s", inspectionContext)
        }</span>

        <span class="cov0" title="0">prompt += "\n\nRespond with a JSON array of violations as specified in the system instructions."

        return prompt</span>
}

// parseClaudeResponse parses Claude's response into DetectedViolation structs
func (s *claudeService) parseClaudeResponse(response string, safetyCodes []SafetyCodeContext) ([]DetectedViolation, string) <span class="cov0" title="0">{
        // Try to extract JSON array from the response
        // Claude might wrap it in markdown code blocks
        jsonStr := s.extractJSON(response)

        var rawViolations []struct {
                SafetyCode  string  `json:"safety_code"`
                Description string  `json:"description"`
                Severity    string  `json:"severity"`
                Confidence  float64 `json:"confidence"`
                Location    string  `json:"location"`
        }

        if err := json.Unmarshal([]byte(jsonStr), &amp;rawViolations); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to parse Claude response as JSON",
                        slog.String("error", err.Error()),
                        slog.String("response", response))
                return []DetectedViolation{}, response
        }</span>

        // Convert to DetectedViolation structs
        <span class="cov0" title="0">violations := make([]DetectedViolation, 0, len(rawViolations))
        for _, raw := range rawViolations </span><span class="cov0" title="0">{
                violation := DetectedViolation{
                        SafetyCode:  raw.SafetyCode,
                        Description: raw.Description,
                        Confidence:  raw.Confidence,
                        Location:    raw.Location,
                }

                // Map severity string to enum
                switch strings.ToLower(raw.Severity) </span>{
                case "critical":<span class="cov0" title="0">
                        violation.Severity = SeverityCritical</span>
                case "high":<span class="cov0" title="0">
                        violation.Severity = SeverityHigh</span>
                case "medium":<span class="cov0" title="0">
                        violation.Severity = SeverityMedium</span>
                case "low":<span class="cov0" title="0">
                        violation.Severity = SeverityLow</span>
                default:<span class="cov0" title="0">
                        violation.Severity = SeverityMedium</span>
                }

                // Try to match safety code to provided safety code IDs
                <span class="cov0" title="0">for _, sc := range safetyCodes </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToUpper(raw.SafetyCode), strings.ToUpper(sc.Code)) </span><span class="cov0" title="0">{
                                violation.SafetyCodeID = sc.Code
                                break</span>
                        }
                }

                <span class="cov0" title="0">violations = append(violations, violation)</span>
        }

        <span class="cov0" title="0">return violations, fmt.Sprintf("Claude identified %d potential violations", len(violations))</span>
}

// extractJSON attempts to extract JSON from a response that might be wrapped in markdown
func (s *claudeService) extractJSON(response string) string <span class="cov0" title="0">{
        // Remove markdown code blocks if present
        response = strings.TrimSpace(response)

        // Check for ```json wrapper
        if strings.HasPrefix(response, "```json") </span><span class="cov0" title="0">{
                response = strings.TrimPrefix(response, "```json")
                response = strings.TrimSuffix(response, "```")
                response = strings.TrimSpace(response)
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(response, "```") </span><span class="cov0" title="0">{
                response = strings.TrimPrefix(response, "```")
                response = strings.TrimSuffix(response, "```")
                response = strings.TrimSpace(response)
        }</span>

        <span class="cov0" title="0">return response</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ai

import (
        "context"
        "log/slog"
)

// mockAIService is a mock implementation for development and testing
type mockAIService struct {
        logger *slog.Logger
}

// newMockAIService creates a new mock AI service
func newMockAIService(logger *slog.Logger) *mockAIService <span class="cov0" title="0">{
        return &amp;mockAIService{
                logger: logger,
        }
}</span>

// AnalyzePhoto returns mock violations for testing
func (s *mockAIService) AnalyzePhoto(ctx context.Context, request AnalysisRequest) (*AnalysisResponse, error) <span class="cov0" title="0">{
        s.logger.Info("ðŸ¤– MOCK AI: Analyzing photo",
                slog.Int("safety_codes_provided", len(request.SafetyCodes)),
                slog.String("has_image_data", func() string </span><span class="cov0" title="0">{
                        if len(request.ImageData) &gt; 0 </span><span class="cov0" title="0">{
                                return "yes"
                        }</span>
                        <span class="cov0" title="0">return "no"</span>
                }()),
                slog.String("image_url", request.ImageURL),
        )

        // Return mock violations for testing
        <span class="cov0" title="0">mockViolations := []DetectedViolation{
                {
                        SafetyCode:  "OSHA 1926.501",
                        Description: "Worker observed at elevated height without proper fall protection system. No guardrails, safety nets, or personal fall arrest system visible.",
                        Severity:    SeverityCritical,
                        Confidence:  0.92,
                        Location:    "Upper left section of image, approximately 15 feet above ground level",
                },
                {
                        SafetyCode:  "OSHA 1926.100",
                        Description: "Worker not wearing required hard hat in construction zone where overhead hazards are present.",
                        Severity:    SeverityHigh,
                        Confidence:  0.87,
                        Location:    "Center of image, worker near scaffolding",
                },
        }

        s.logger.Info("ðŸ¤– MOCK AI: Analysis complete",
                slog.Int("violations_detected", len(mockViolations)),
        )

        return &amp;AnalysisResponse{
                Violations:      mockViolations,
                AnalysisDetails: "Mock AI analysis - this is simulated data for testing purposes",
                TokensUsed:      0,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "errors"

        "golang.org/x/crypto/bcrypt"
)

// HashPassword generates a bcrypt hash of the password
func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        if password == "" </span><span class="cov8" title="1">{
                return "", errors.New("password cannot be empty")
        }</span>

        <span class="cov8" title="1">hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(hash), nil</span>
}

// VerifyPassword compares a password with a hash to check if they match
func VerifyPassword(password, hash string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "crypto/rand"
        "encoding/base64"
)

const (
        // VerificationTokenLength is the length of verification tokens in bytes
        VerificationTokenLength = 32
)

// GenerateVerificationToken generates a cryptographically secure random token
// for email verification or password reset
func GenerateVerificationToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, VerificationTokenLength)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(b), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "flag"
        "fmt"
        "log"
        "log/slog"
        "os"
        "path/filepath"
        "time"

        "github.com/joho/godotenv"
)

type Config struct {
        App      AppConfig
        Database DatabaseConfig
        Auth     AuthConfig
        Session  SessionConfig
        Email    EmailConfig
        Storage  StorageConfig
        AI       AIConfig
        Logger   LoggerConfig
}

type AppConfig struct {
        Host string
        Port int
        Env  string
}

type DatabaseConfig struct {
        Username string
        Password string
        Host     string
        Port     string
        DbName   string
}

type AuthConfig struct {
        JWTSecret     string
        JWTExpiration time.Duration
}

type SessionConfig struct {
        CookieName string
        Duration   time.Duration
        Secure     bool
}

type EmailConfig struct {
        Provider        string // "mock" or "postmark"
        PostmarkToken   string
        PostmarkAccount string
        FromAddress     string
        FromName        string
        VerifyBaseURL   string // Base URL for verification links (e.g., "http://localhost:1323")
}

type StorageConfig struct {
        Provider   string // "local" or "s3"
        LocalPath  string // Path for local storage
        LocalURL   string // Base URL for local storage
        S3Bucket   string // S3 bucket name
        S3Region   string // S3 region
        S3BaseURL  string // CloudFront or S3 base URL
}

type AIConfig struct {
        Provider     string  // "mock" or "claude"
        ClaudeAPIKey string  // Anthropic API key
        ClaudeModel  string  // Claude model to use
        MaxTokens    int     // Maximum tokens for AI responses
        Temperature  float64 // Temperature for AI responses (0.0 - 1.0)
}

type LoggerConfig struct {
        Level slog.Level
}

var (
        flagsInitialized = false
        flagHost         *string
        flagPort         *int
        flagEnv          *string
        flagLogLevel     *string
        flagDbUser       *string
        flagDbPassword   *string
        flagDbHost       *string
        flagDbPort       *string
        flagDbName       *string
)

func initFlags() <span class="cov0" title="0">{
        if !flagsInitialized </span><span class="cov0" title="0">{
                flagHost = flag.String("host", getEnv("SERVER_HOST", "localhost"), "server host")
                flagPort = flag.Int("port", getEnvInt("SERVER_PORT", 8080), "server port")
                flagEnv = flag.String("env", getEnv("ENVIRONMENT", "prod"), "environment: prod, dev")
                flagLogLevel = flag.String("log_level", getEnv("LOG_LEVEL", "info"), "log level: debug, info, warn, error")
                flagDbUser = flag.String("db_user", getEnv("DB_USER", "postgres"), "postgres database username")
                flagDbPassword = flag.String("db_password", getEnv("DB_PASSWORD", ""), "postgres database password")
                flagDbHost = flag.String("db_hostname", getEnv("DB_HOSTNAME", "localhost"), "postgres database hostname")
                flagDbPort = flag.String("db_port", getEnv("DB_PORT", "5432"), "postgres database port")
                flagDbName = flag.String("db_name", getEnv("DB_NAME", "postgres"), "postgres database name")
                flagsInitialized = true
        }</span>
        <span class="cov0" title="0">if !flag.Parsed() </span><span class="cov0" title="0">{
                flag.Parse()
        }</span>
}

// Load loads configuration from environment variables and command-line flags
func Load() (*Config, error) <span class="cov0" title="0">{
        // Try to load .env from current directory, then walk up to find it (max 2 levels)
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                // Walk up directories to find .env (max 2 parent directories)
                dir, _ := os.Getwd()
                found := false
                for i := 0; i &lt; 2; i++ </span><span class="cov0" title="0">{
                        dir = filepath.Join(dir, "..")
                        if err := godotenv.Load(filepath.Join(dir, ".env")); err == nil </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        log.Println("Warning: .env file not found, using environment variables and defaults")
                }</span>
        }

        // Initialize and parse flags
        <span class="cov0" title="0">initFlags()

        // Set up logging
        var programLevel = new(slog.LevelVar) // Info by default
        switch *flagLogLevel </span>{
        case "error":<span class="cov0" title="0">
                programLevel.Set(slog.LevelError)</span>
        case "warn":<span class="cov0" title="0">
                programLevel.Set(slog.LevelWarn)</span>
        case "debug":<span class="cov0" title="0">
                programLevel.Set(slog.LevelDebug)</span>
        default:<span class="cov0" title="0">
                programLevel.Set(slog.LevelInfo)</span>
        }

        <span class="cov0" title="0">cfg := &amp;Config{
                App: AppConfig{
                        Host: *flagHost,
                        Port: *flagPort,
                        Env:  *flagEnv,
                },
                Database: DatabaseConfig{
                        Username: *flagDbUser,
                        Password: *flagDbPassword,
                        Host:     *flagDbHost,
                        Port:     *flagDbPort,
                        DbName:   *flagDbName,
                },
                Auth: AuthConfig{
                        JWTSecret:     getEnv("JWT_SECRET", "your-secret-key-change-in-production"),
                        JWTExpiration: 24 * time.Hour * 7, // 7 days
                },
                Session: SessionConfig{
                        CookieName: "session_token",
                        Duration:   24 * time.Hour * 7, // 7 days
                        Secure:     *flagEnv == "prod" || *flagEnv == "production",
                },
                Email: EmailConfig{
                        Provider:        getEnv("EMAIL_PROVIDER", "mock"),
                        PostmarkToken:   getEnv("POSTMARK_SERVER_TOKEN", ""),
                        PostmarkAccount: getEnv("POSTMARK_ACCOUNT_TOKEN", ""),
                        FromAddress:     getEnv("EMAIL_FROM_ADDRESS", "noreply@example.com"),
                        FromName:        getEnv("EMAIL_FROM_NAME", "Aletheia"),
                        VerifyBaseURL:   getEnv("EMAIL_VERIFY_BASE_URL", "http://localhost:1323"),
                },
                Storage: StorageConfig{
                        Provider:  getEnv("STORAGE_PROVIDER", "local"),
                        LocalPath: getEnv("STORAGE_LOCAL_PATH", "./uploads"),
                        LocalURL:  getEnv("STORAGE_LOCAL_URL", "http://localhost:1323/uploads"),
                        S3Bucket:  getEnv("STORAGE_S3_BUCKET", ""),
                        S3Region:  getEnv("STORAGE_S3_REGION", "us-east-1"),
                        S3BaseURL: getEnv("STORAGE_S3_BASE_URL", ""),
                },
                AI: AIConfig{
                        Provider:     getEnv("AI_PROVIDER", "mock"),
                        ClaudeAPIKey: getEnv("CLAUDE_API_KEY", ""),
                        ClaudeModel:  getEnv("CLAUDE_MODEL", "claude-3-5-sonnet-20241022"),
                        MaxTokens:    getEnvInt("AI_MAX_TOKENS", 4096),
                        Temperature:  getEnvFloat("AI_TEMPERATURE", 0.3),
                },
                Logger: LoggerConfig{
                        Level: programLevel.Level(),
                },
        }

        // Validate JWT secret in production
        if (cfg.App.Env == "prod" || cfg.App.Env == "production") &amp;&amp; cfg.Auth.JWTSecret == "your-secret-key-change-in-production" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JWT_SECRET must be set in production environment")
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func (c *Config) GetLogger() slog.Handler <span class="cov0" title="0">{
        var handler slog.Handler
        logLevel := c.Logger.Level
        switch c.App.Env </span>{
        case "prod", "production":<span class="cov0" title="0">
                handler = slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{
                        Level: logLevel,
                        ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                                if a.Key == slog.TimeKey </span><span class="cov0" title="0">{
                                        return slog.String("time", a.Value.Time().Format(time.RFC3339Nano))
                                }</span>
                                <span class="cov0" title="0">return a</span>
                        },
                })
        default:<span class="cov0" title="0">
                handler = slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{Level: logLevel})</span>
        }
        <span class="cov0" title="0">return handler</span>
}

func (c *Config) GetConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("postgresql://%s:%s@%s:%s/%s", c.Database.Username, c.Database.Password, c.Database.Host, c.Database.Port, c.Database.DbName)
}</span>

// Helper functions
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                var intValue int
                if _, err := fmt.Sscanf(value, "%d", &amp;intValue); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvFloat(key string, defaultValue float64) float64 <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                var floatValue float64
                if _, err := fmt.Sscanf(value, "%f", &amp;floatValue); err == nil </span><span class="cov0" title="0">{
                        return floatValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: detected_violations.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createDetectedViolation = `-- name: CreateDetectedViolation :one
INSERT INTO detected_violations (
  photo_id,
  description,
  confidence_score,
  safety_code_id,
  status
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, photo_id, description, confidence_score, status, created_at, safety_code_id
`

type CreateDetectedViolationParams struct {
        PhotoID         pgtype.UUID     `json:"photo_id"`
        Description     string          `json:"description"`
        ConfidenceScore pgtype.Numeric  `json:"confidence_score"`
        SafetyCodeID    pgtype.UUID     `json:"safety_code_id"`
        Status          ViolationStatus `json:"status"`
}

func (q *Queries) CreateDetectedViolation(ctx context.Context, arg CreateDetectedViolationParams) (DetectedViolation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createDetectedViolation,
                arg.PhotoID,
                arg.Description,
                arg.ConfidenceScore,
                arg.SafetyCodeID,
                arg.Status,
        )
        var i DetectedViolation
        err := row.Scan(
                &amp;i.ID,
                &amp;i.PhotoID,
                &amp;i.Description,
                &amp;i.ConfidenceScore,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.SafetyCodeID,
        )
        return i, err
}</span>

const deleteDetectedViolation = `-- name: DeleteDetectedViolation :exec
DELETE FROM detected_violations
WHERE id = $1
`

func (q *Queries) DeleteDetectedViolation(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteDetectedViolation, id)
        return err
}</span>

const getDetectedViolation = `-- name: GetDetectedViolation :one
SELECT id, photo_id, description, confidence_score, status, created_at, safety_code_id FROM detected_violations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDetectedViolation(ctx context.Context, id pgtype.UUID) (DetectedViolation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getDetectedViolation, id)
        var i DetectedViolation
        err := row.Scan(
                &amp;i.ID,
                &amp;i.PhotoID,
                &amp;i.Description,
                &amp;i.ConfidenceScore,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.SafetyCodeID,
        )
        return i, err
}</span>

const listDetectedViolations = `-- name: ListDetectedViolations :many
SELECT id, photo_id, description, confidence_score, status, created_at, safety_code_id FROM detected_violations
WHERE photo_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListDetectedViolations(ctx context.Context, photoID pgtype.UUID) ([]DetectedViolation, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listDetectedViolations, photoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []DetectedViolation{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i DetectedViolation
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.PhotoID,
                        &amp;i.Description,
                        &amp;i.ConfidenceScore,
                        &amp;i.Status,
                        &amp;i.CreatedAt,
                        &amp;i.SafetyCodeID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listDetectedViolationsByStatus = `-- name: ListDetectedViolationsByStatus :many
SELECT id, photo_id, description, confidence_score, status, created_at, safety_code_id FROM detected_violations
WHERE photo_id = $1 AND status = $2
ORDER BY created_at DESC
`

type ListDetectedViolationsByStatusParams struct {
        PhotoID pgtype.UUID     `json:"photo_id"`
        Status  ViolationStatus `json:"status"`
}

func (q *Queries) ListDetectedViolationsByStatus(ctx context.Context, arg ListDetectedViolationsByStatusParams) ([]DetectedViolation, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listDetectedViolationsByStatus, arg.PhotoID, arg.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []DetectedViolation{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i DetectedViolation
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.PhotoID,
                        &amp;i.Description,
                        &amp;i.ConfidenceScore,
                        &amp;i.Status,
                        &amp;i.CreatedAt,
                        &amp;i.SafetyCodeID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateDetectedViolationSafetyCode = `-- name: UpdateDetectedViolationSafetyCode :one
UPDATE detected_violations
SET safety_code_id = $2
WHERE id = $1
RETURNING id, photo_id, description, confidence_score, status, created_at, safety_code_id
`

type UpdateDetectedViolationSafetyCodeParams struct {
        ID           pgtype.UUID `json:"id"`
        SafetyCodeID pgtype.UUID `json:"safety_code_id"`
}

func (q *Queries) UpdateDetectedViolationSafetyCode(ctx context.Context, arg UpdateDetectedViolationSafetyCodeParams) (DetectedViolation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateDetectedViolationSafetyCode, arg.ID, arg.SafetyCodeID)
        var i DetectedViolation
        err := row.Scan(
                &amp;i.ID,
                &amp;i.PhotoID,
                &amp;i.Description,
                &amp;i.ConfidenceScore,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.SafetyCodeID,
        )
        return i, err
}</span>

const updateDetectedViolationStatus = `-- name: UpdateDetectedViolationStatus :one
UPDATE detected_violations
SET status = $2
WHERE id = $1
RETURNING id, photo_id, description, confidence_score, status, created_at, safety_code_id
`

type UpdateDetectedViolationStatusParams struct {
        ID     pgtype.UUID     `json:"id"`
        Status ViolationStatus `json:"status"`
}

func (q *Queries) UpdateDetectedViolationStatus(ctx context.Context, arg UpdateDetectedViolationStatusParams) (DetectedViolation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateDetectedViolationStatus, arg.ID, arg.Status)
        var i DetectedViolation
        err := row.Scan(
                &amp;i.ID,
                &amp;i.PhotoID,
                &amp;i.Description,
                &amp;i.ConfidenceScore,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.SafetyCodeID,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inspections.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createInspection = `-- name: CreateInspection :one
INSERT INTO inspections (
  project_id,
  inspector_id,
  status
) VALUES (
  $1, $2, $3
)
RETURNING id, project_id, inspector_id, status, created_at, updated_at
`

type CreateInspectionParams struct {
        ProjectID   pgtype.UUID      `json:"project_id"`
        InspectorID pgtype.UUID      `json:"inspector_id"`
        Status      InspectionStatus `json:"status"`
}

func (q *Queries) CreateInspection(ctx context.Context, arg CreateInspectionParams) (Inspection, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createInspection, arg.ProjectID, arg.InspectorID, arg.Status)
        var i Inspection
        err := row.Scan(
                &amp;i.ID,
                &amp;i.ProjectID,
                &amp;i.InspectorID,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const deleteInspection = `-- name: DeleteInspection :exec
DELETE FROM inspections
WHERE id = $1
`

func (q *Queries) DeleteInspection(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteInspection, id)
        return err
}</span>

const getInspection = `-- name: GetInspection :one
SELECT id, project_id, inspector_id, status, created_at, updated_at FROM inspections
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetInspection(ctx context.Context, id pgtype.UUID) (Inspection, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getInspection, id)
        var i Inspection
        err := row.Scan(
                &amp;i.ID,
                &amp;i.ProjectID,
                &amp;i.InspectorID,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const listInspections = `-- name: ListInspections :many
SELECT id, project_id, inspector_id, status, created_at, updated_at FROM inspections
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInspections(ctx context.Context, projectID pgtype.UUID) ([]Inspection, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listInspections, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Inspection{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Inspection
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.ProjectID,
                        &amp;i.InspectorID,
                        &amp;i.Status,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listInspectionsByInspector = `-- name: ListInspectionsByInspector :many
SELECT id, project_id, inspector_id, status, created_at, updated_at FROM inspections
WHERE inspector_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInspectionsByInspector(ctx context.Context, inspectorID pgtype.UUID) ([]Inspection, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listInspectionsByInspector, inspectorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Inspection{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Inspection
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.ProjectID,
                        &amp;i.InspectorID,
                        &amp;i.Status,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listInspectionsByStatus = `-- name: ListInspectionsByStatus :many
SELECT id, project_id, inspector_id, status, created_at, updated_at FROM inspections
WHERE project_id = $1 AND status = $2
ORDER BY created_at DESC
`

type ListInspectionsByStatusParams struct {
        ProjectID pgtype.UUID      `json:"project_id"`
        Status    InspectionStatus `json:"status"`
}

func (q *Queries) ListInspectionsByStatus(ctx context.Context, arg ListInspectionsByStatusParams) ([]Inspection, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listInspectionsByStatus, arg.ProjectID, arg.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Inspection{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Inspection
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.ProjectID,
                        &amp;i.InspectorID,
                        &amp;i.Status,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateInspectionStatus = `-- name: UpdateInspectionStatus :one
UPDATE inspections
SET
  status = $2,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, project_id, inspector_id, status, created_at, updated_at
`

type UpdateInspectionStatusParams struct {
        ID     pgtype.UUID      `json:"id"`
        Status InspectionStatus `json:"status"`
}

func (q *Queries) UpdateInspectionStatus(ctx context.Context, arg UpdateInspectionStatusParams) (Inspection, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateInspectionStatus, arg.ID, arg.Status)
        var i Inspection
        err := row.Scan(
                &amp;i.ID,
                &amp;i.ProjectID,
                &amp;i.InspectorID,
                &amp;i.Status,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type InspectionStatus string

const (
        InspectionStatusDraft      InspectionStatus = "draft"
        InspectionStatusInProgress InspectionStatus = "in_progress"
        InspectionStatusCompleted  InspectionStatus = "completed"
)

func (e *InspectionStatus) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = InspectionStatus(s)</span>
        case string:<span class="cov0" title="0">
                *e = InspectionStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for InspectionStatus: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullInspectionStatus struct {
        InspectionStatus InspectionStatus `json:"inspection_status"`
        Valid            bool             `json:"valid"` // Valid is true if InspectionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInspectionStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.InspectionStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.InspectionStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullInspectionStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.InspectionStatus), nil</span>
}

type OrganizationRole string

const (
        OrganizationRoleOwner  OrganizationRole = "owner"
        OrganizationRoleAdmin  OrganizationRole = "admin"
        OrganizationRoleMember OrganizationRole = "member"
)

func (e *OrganizationRole) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = OrganizationRole(s)</span>
        case string:<span class="cov0" title="0">
                *e = OrganizationRole(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for OrganizationRole: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullOrganizationRole struct {
        OrganizationRole OrganizationRole `json:"organization_role"`
        Valid            bool             `json:"valid"` // Valid is true if OrganizationRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrganizationRole) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.OrganizationRole, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.OrganizationRole.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullOrganizationRole) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.OrganizationRole), nil</span>
}

type UserStatus string

const (
        UserStatusActive    UserStatus = "active"
        UserStatusSuspended UserStatus = "suspended"
        UserStatusDeleted   UserStatus = "deleted"
)

func (e *UserStatus) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = UserStatus(s)</span>
        case string:<span class="cov0" title="0">
                *e = UserStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for UserStatus: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullUserStatus struct {
        UserStatus UserStatus `json:"user_status"`
        Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.UserStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.UserStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.UserStatus), nil</span>
}

type ViolationStatus string

const (
        ViolationStatusPending   ViolationStatus = "pending"
        ViolationStatusConfirmed ViolationStatus = "confirmed"
        ViolationStatusDismissed ViolationStatus = "dismissed"
)

func (e *ViolationStatus) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = ViolationStatus(s)</span>
        case string:<span class="cov0" title="0">
                *e = ViolationStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for ViolationStatus: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullViolationStatus struct {
        ViolationStatus ViolationStatus `json:"violation_status"`
        Valid           bool            `json:"valid"` // Valid is true if ViolationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullViolationStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.ViolationStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.ViolationStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullViolationStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.ViolationStatus), nil</span>
}

type DetectedViolation struct {
        ID              pgtype.UUID        `json:"id"`
        PhotoID         pgtype.UUID        `json:"photo_id"`
        Description     string             `json:"description"`
        ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
        Status          ViolationStatus    `json:"status"`
        CreatedAt       pgtype.Timestamptz `json:"created_at"`
        SafetyCodeID    pgtype.UUID        `json:"safety_code_id"`
}

type Inspection struct {
        ID          pgtype.UUID        `json:"id"`
        ProjectID   pgtype.UUID        `json:"project_id"`
        InspectorID pgtype.UUID        `json:"inspector_id"`
        Status      InspectionStatus   `json:"status"`
        CreatedAt   pgtype.Timestamptz `json:"created_at"`
        UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type Organization struct {
        ID        pgtype.UUID        `json:"id"`
        Name      string             `json:"name"`
        CreatedAt pgtype.Timestamptz `json:"created_at"`
        UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type OrganizationMember struct {
        ID             pgtype.UUID        `json:"id"`
        OrganizationID pgtype.UUID        `json:"organization_id"`
        UserID         pgtype.UUID        `json:"user_id"`
        Role           OrganizationRole   `json:"role"`
        CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type Photo struct {
        ID           pgtype.UUID        `json:"id"`
        InspectionID pgtype.UUID        `json:"inspection_id"`
        StorageUrl   string             `json:"storage_url"`
        CreatedAt    pgtype.Timestamptz `json:"created_at"`
        ThumbnailUrl pgtype.Text        `json:"thumbnail_url"`
}

type Project struct {
        ID             pgtype.UUID        `json:"id"`
        OrganizationID pgtype.UUID        `json:"organization_id"`
        Name           string             `json:"name"`
        CreatedAt      pgtype.Timestamptz `json:"created_at"`
        UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

type Report struct {
        ID           pgtype.UUID        `json:"id"`
        InspectionID pgtype.UUID        `json:"inspection_id"`
        StorageUrl   string             `json:"storage_url"`
        CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type SafetyCode struct {
        ID            pgtype.UUID        `json:"id"`
        Code          string             `json:"code"`
        Description   string             `json:"description"`
        Country       pgtype.Text        `json:"country"`
        StateProvince pgtype.Text        `json:"state_province"`
        CreatedAt     pgtype.Timestamptz `json:"created_at"`
        UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type Session struct {
        ID        int32              `json:"id"`
        UserID    pgtype.UUID        `json:"user_id"`
        Token     string             `json:"token"`
        ExpiresAt pgtype.Timestamptz `json:"expires_at"`
        CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type User struct {
        ID                  pgtype.UUID        `json:"id"`
        Email               string             `json:"email"`
        Username            string             `json:"username"`
        PasswordHash        string             `json:"password_hash"`
        FirstName           pgtype.Text        `json:"first_name"`
        LastName            pgtype.Text        `json:"last_name"`
        Status              UserStatus         `json:"status"`
        StatusReason        pgtype.Text        `json:"status_reason"`
        CreatedAt           pgtype.Timestamptz `json:"created_at"`
        UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
        LastLoginAt         pgtype.Timestamptz `json:"last_login_at"`
        VerifiedAt          pgtype.Timestamptz `json:"verified_at"`
        VerificationToken   pgtype.Text        `json:"verification_token"`
        ResetToken          pgtype.Text        `json:"reset_token"`
        ResetTokenExpiresAt pgtype.Timestamptz `json:"reset_token_expires_at"`
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organization_members.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const addOrganizationMember = `-- name: AddOrganizationMember :one
INSERT INTO organization_members (
  organization_id,
  user_id,
  role
) VALUES (
  $1, $2, $3
)
RETURNING id, organization_id, user_id, role, created_at
`

type AddOrganizationMemberParams struct {
        OrganizationID pgtype.UUID      `json:"organization_id"`
        UserID         pgtype.UUID      `json:"user_id"`
        Role           OrganizationRole `json:"role"`
}

func (q *Queries) AddOrganizationMember(ctx context.Context, arg AddOrganizationMemberParams) (OrganizationMember, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, addOrganizationMember, arg.OrganizationID, arg.UserID, arg.Role)
        var i OrganizationMember
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.UserID,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getOrganizationMember = `-- name: GetOrganizationMember :one
SELECT id, organization_id, user_id, role, created_at FROM organization_members
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrganizationMember(ctx context.Context, id pgtype.UUID) (OrganizationMember, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrganizationMember, id)
        var i OrganizationMember
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.UserID,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getOrganizationMemberByUserAndOrg = `-- name: GetOrganizationMemberByUserAndOrg :one
SELECT id, organization_id, user_id, role, created_at FROM organization_members
WHERE organization_id = $1 AND user_id = $2 LIMIT 1
`

type GetOrganizationMemberByUserAndOrgParams struct {
        OrganizationID pgtype.UUID `json:"organization_id"`
        UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetOrganizationMemberByUserAndOrg(ctx context.Context, arg GetOrganizationMemberByUserAndOrgParams) (OrganizationMember, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrganizationMemberByUserAndOrg, arg.OrganizationID, arg.UserID)
        var i OrganizationMember
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.UserID,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT id, organization_id, user_id, role, created_at FROM organization_members
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID pgtype.UUID) ([]OrganizationMember, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrganizationMembers, organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []OrganizationMember{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i OrganizationMember
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.OrganizationID,
                        &amp;i.UserID,
                        &amp;i.Role,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listUserOrganizations = `-- name: ListUserOrganizations :many
SELECT id, organization_id, user_id, role, created_at FROM organization_members
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserOrganizations(ctx context.Context, userID pgtype.UUID) ([]OrganizationMember, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listUserOrganizations, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []OrganizationMember{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i OrganizationMember
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.OrganizationID,
                        &amp;i.UserID,
                        &amp;i.Role,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const removeOrganizationMember = `-- name: RemoveOrganizationMember :exec
DELETE FROM organization_members
WHERE id = $1
`

func (q *Queries) RemoveOrganizationMember(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, removeOrganizationMember, id)
        return err
}</span>

const updateOrganizationMemberRole = `-- name: UpdateOrganizationMemberRole :one
UPDATE organization_members
SET role = $2
WHERE id = $1
RETURNING id, organization_id, user_id, role, created_at
`

type UpdateOrganizationMemberRoleParams struct {
        ID   pgtype.UUID      `json:"id"`
        Role OrganizationRole `json:"role"`
}

func (q *Queries) UpdateOrganizationMemberRole(ctx context.Context, arg UpdateOrganizationMemberRoleParams) (OrganizationMember, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrganizationMemberRole, arg.ID, arg.Role)
        var i OrganizationMember
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.UserID,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (
  name
) VALUES (
  $1
)
RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateOrganization(ctx context.Context, name string) (Organization, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createOrganization, name)
        var i Organization
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteOrganization, id)
        return err
}</span>

const getOrganization = `-- name: GetOrganization :one
SELECT id, name, created_at, updated_at FROM organizations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrganization(ctx context.Context, id pgtype.UUID) (Organization, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrganization, id)
        var i Organization
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, created_at, updated_at FROM organizations
ORDER BY created_at DESC
`

func (q *Queries) ListOrganizations(ctx context.Context) ([]Organization, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrganizations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Organization{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Organization
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const searchOrganizationsByName = `-- name: SearchOrganizationsByName :many
SELECT id, name, created_at, updated_at FROM organizations
WHERE name ILIKE '%' || $1 || '%'
ORDER BY name
`

func (q *Queries) SearchOrganizationsByName(ctx context.Context, dollar_1 pgtype.Text) ([]Organization, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, searchOrganizationsByName, dollar_1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Organization{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Organization
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE organizations
SET
  name = COALESCE($2, name),
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, created_at, updated_at
`

type UpdateOrganizationParams struct {
        ID   pgtype.UUID `json:"id"`
        Name string      `json:"name"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (Organization, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrganization, arg.ID, arg.Name)
        var i Organization
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: photos.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createPhoto = `-- name: CreatePhoto :one
INSERT INTO photos (
  inspection_id,
  storage_url,
  thumbnail_url
) VALUES (
  $1, $2, $3
)
RETURNING id, inspection_id, storage_url, created_at, thumbnail_url
`

type CreatePhotoParams struct {
        InspectionID pgtype.UUID `json:"inspection_id"`
        StorageUrl   string      `json:"storage_url"`
        ThumbnailUrl pgtype.Text `json:"thumbnail_url"`
}

func (q *Queries) CreatePhoto(ctx context.Context, arg CreatePhotoParams) (Photo, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createPhoto, arg.InspectionID, arg.StorageUrl, arg.ThumbnailUrl)
        var i Photo
        err := row.Scan(
                &amp;i.ID,
                &amp;i.InspectionID,
                &amp;i.StorageUrl,
                &amp;i.CreatedAt,
                &amp;i.ThumbnailUrl,
        )
        return i, err
}</span>

const deletePhoto = `-- name: DeletePhoto :exec
DELETE FROM photos
WHERE id = $1
`

func (q *Queries) DeletePhoto(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deletePhoto, id)
        return err
}</span>

const getPhoto = `-- name: GetPhoto :one
SELECT id, inspection_id, storage_url, created_at, thumbnail_url FROM photos
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPhoto(ctx context.Context, id pgtype.UUID) (Photo, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getPhoto, id)
        var i Photo
        err := row.Scan(
                &amp;i.ID,
                &amp;i.InspectionID,
                &amp;i.StorageUrl,
                &amp;i.CreatedAt,
                &amp;i.ThumbnailUrl,
        )
        return i, err
}</span>

const listPhotos = `-- name: ListPhotos :many
SELECT id, inspection_id, storage_url, created_at, thumbnail_url FROM photos
WHERE inspection_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPhotos(ctx context.Context, inspectionID pgtype.UUID) ([]Photo, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listPhotos, inspectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Photo{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Photo
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.InspectionID,
                        &amp;i.StorageUrl,
                        &amp;i.CreatedAt,
                        &amp;i.ThumbnailUrl,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
  organization_id,
  name
) VALUES (
  $1, $2
)
RETURNING id, organization_id, name, created_at, updated_at
`

type CreateProjectParams struct {
        OrganizationID pgtype.UUID `json:"organization_id"`
        Name           string      `json:"name"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createProject, arg.OrganizationID, arg.Name)
        var i Project
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.Name,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteProject, id)
        return err
}</span>

const getProject = `-- name: GetProject :one
SELECT id, organization_id, name, created_at, updated_at FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id pgtype.UUID) (Project, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getProject, id)
        var i Project
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.Name,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const listProjects = `-- name: ListProjects :many
SELECT id, organization_id, name, created_at, updated_at FROM projects
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context, organizationID pgtype.UUID) ([]Project, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listProjects, organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Project{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Project
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.OrganizationID,
                        &amp;i.Name,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET
  name = COALESCE($2, name),
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, organization_id, name, created_at, updated_at
`

type UpdateProjectParams struct {
        ID   pgtype.UUID `json:"id"`
        Name string      `json:"name"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateProject, arg.ID, arg.Name)
        var i Project
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrganizationID,
                &amp;i.Name,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
  inspection_id,
  storage_url
) VALUES (
  $1, $2
)
RETURNING id, inspection_id, storage_url, created_at
`

type CreateReportParams struct {
        InspectionID pgtype.UUID `json:"inspection_id"`
        StorageUrl   string      `json:"storage_url"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (Report, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createReport, arg.InspectionID, arg.StorageUrl)
        var i Report
        err := row.Scan(
                &amp;i.ID,
                &amp;i.InspectionID,
                &amp;i.StorageUrl,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteReport = `-- name: DeleteReport :exec
DELETE FROM reports
WHERE id = $1
`

func (q *Queries) DeleteReport(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteReport, id)
        return err
}</span>

const getReport = `-- name: GetReport :one
SELECT id, inspection_id, storage_url, created_at FROM reports
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetReport(ctx context.Context, id pgtype.UUID) (Report, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getReport, id)
        var i Report
        err := row.Scan(
                &amp;i.ID,
                &amp;i.InspectionID,
                &amp;i.StorageUrl,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listReports = `-- name: ListReports :many
SELECT id, inspection_id, storage_url, created_at FROM reports
WHERE inspection_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListReports(ctx context.Context, inspectionID pgtype.UUID) ([]Report, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listReports, inspectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Report{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Report
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.InspectionID,
                        &amp;i.StorageUrl,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: safety_codes.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createSafetyCode = `-- name: CreateSafetyCode :one
INSERT INTO safety_codes (
  code,
  description,
  country,
  state_province
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, code, description, country, state_province, created_at, updated_at
`

type CreateSafetyCodeParams struct {
        Code          string      `json:"code"`
        Description   string      `json:"description"`
        Country       pgtype.Text `json:"country"`
        StateProvince pgtype.Text `json:"state_province"`
}

func (q *Queries) CreateSafetyCode(ctx context.Context, arg CreateSafetyCodeParams) (SafetyCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createSafetyCode,
                arg.Code,
                arg.Description,
                arg.Country,
                arg.StateProvince,
        )
        var i SafetyCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Description,
                &amp;i.Country,
                &amp;i.StateProvince,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const deleteSafetyCode = `-- name: DeleteSafetyCode :exec
DELETE FROM safety_codes
WHERE id = $1
`

func (q *Queries) DeleteSafetyCode(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteSafetyCode, id)
        return err
}</span>

const getSafetyCode = `-- name: GetSafetyCode :one
SELECT id, code, description, country, state_province, created_at, updated_at FROM safety_codes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSafetyCode(ctx context.Context, id pgtype.UUID) (SafetyCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSafetyCode, id)
        var i SafetyCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Description,
                &amp;i.Country,
                &amp;i.StateProvince,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getSafetyCodeByCode = `-- name: GetSafetyCodeByCode :one
SELECT id, code, description, country, state_province, created_at, updated_at FROM safety_codes
WHERE code = $1 LIMIT 1
`

func (q *Queries) GetSafetyCodeByCode(ctx context.Context, code string) (SafetyCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSafetyCodeByCode, code)
        var i SafetyCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Description,
                &amp;i.Country,
                &amp;i.StateProvince,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const listSafetyCodes = `-- name: ListSafetyCodes :many
SELECT id, code, description, country, state_province, created_at, updated_at FROM safety_codes
ORDER BY code
`

func (q *Queries) ListSafetyCodes(ctx context.Context) ([]SafetyCode, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listSafetyCodes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []SafetyCode{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i SafetyCode
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Code,
                        &amp;i.Description,
                        &amp;i.Country,
                        &amp;i.StateProvince,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listSafetyCodesByCountry = `-- name: ListSafetyCodesByCountry :many
SELECT id, code, description, country, state_province, created_at, updated_at FROM safety_codes
WHERE country = $1
ORDER BY code
`

func (q *Queries) ListSafetyCodesByCountry(ctx context.Context, country pgtype.Text) ([]SafetyCode, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listSafetyCodesByCountry, country)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []SafetyCode{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i SafetyCode
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Code,
                        &amp;i.Description,
                        &amp;i.Country,
                        &amp;i.StateProvince,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listSafetyCodesByStateProvince = `-- name: ListSafetyCodesByStateProvince :many
SELECT id, code, description, country, state_province, created_at, updated_at FROM safety_codes
WHERE state_province = $1
ORDER BY code
`

func (q *Queries) ListSafetyCodesByStateProvince(ctx context.Context, stateProvince pgtype.Text) ([]SafetyCode, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listSafetyCodesByStateProvince, stateProvince)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []SafetyCode{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i SafetyCode
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Code,
                        &amp;i.Description,
                        &amp;i.Country,
                        &amp;i.StateProvince,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateSafetyCode = `-- name: UpdateSafetyCode :one
UPDATE safety_codes
SET
  code = COALESCE($2, code),
  description = COALESCE($3, description),
  country = COALESCE($4, country),
  state_province = COALESCE($5, state_province),
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, code, description, country, state_province, created_at, updated_at
`

type UpdateSafetyCodeParams struct {
        ID            pgtype.UUID `json:"id"`
        Code          string      `json:"code"`
        Description   string      `json:"description"`
        Country       pgtype.Text `json:"country"`
        StateProvince pgtype.Text `json:"state_province"`
}

func (q *Queries) UpdateSafetyCode(ctx context.Context, arg UpdateSafetyCodeParams) (SafetyCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateSafetyCode,
                arg.ID,
                arg.Code,
                arg.Description,
                arg.Country,
                arg.StateProvince,
        )
        var i SafetyCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Description,
                &amp;i.Country,
                &amp;i.StateProvince,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  user_id,
  token,
  expires_at
) VALUES (
  $1, $2, $3
)
RETURNING id, user_id, token, expires_at, created_at
`

type CreateSessionParams struct {
        UserID    pgtype.UUID        `json:"user_id"`
        Token     string             `json:"token"`
        ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createSession, arg.UserID, arg.Token, arg.ExpiresAt)
        var i Session
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Token,
                &amp;i.ExpiresAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at &lt;= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteExpiredSessions)
        return err
}</span>

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteSession, token)
        return err
}</span>

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteUserSessions, userID)
        return err
}</span>

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, user_id, token, expires_at, created_at FROM sessions
WHERE token = $1
  AND expires_at &gt; CURRENT_TIMESTAMP
LIMIT 1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSessionByToken, token)
        var i Session
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Token,
                &amp;i.ExpiresAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package database

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email,
  username,
  password_hash,
  first_name,
  last_name
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at
`

type CreateUserParams struct {
        Email        string      `json:"email"`
        Username     string      `json:"username"`
        PasswordHash string      `json:"password_hash"`
        FirstName    pgtype.Text `json:"first_name"`
        LastName     pgtype.Text `json:"last_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createUser,
                arg.Email,
                arg.Username,
                arg.PasswordHash,
                arg.FirstName,
                arg.LastName,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteUser, id)
        return err
}</span>

const getUser = `-- name: GetUser :one
SELECT id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUser, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const getUserByResetToken = `-- name: GetUserByResetToken :one
SELECT id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at FROM users
WHERE reset_token = $1
  AND reset_token_expires_at &gt; CURRENT_TIMESTAMP
LIMIT 1
`

func (q *Queries) GetUserByResetToken(ctx context.Context, resetToken pgtype.Text) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByResetToken, resetToken)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByUsername, username)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const getUserByVerificationToken = `-- name: GetUserByVerificationToken :one
SELECT id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at FROM users
WHERE verification_token = $1
  AND verified_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByVerificationToken(ctx context.Context, verificationToken pgtype.Text) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByVerificationToken, verificationToken)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const listUsers = `-- name: ListUsers :many
SELECT id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at FROM users
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context, status UserStatus) ([]User, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listUsers, status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []User{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i User
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Email,
                        &amp;i.Username,
                        &amp;i.PasswordHash,
                        &amp;i.FirstName,
                        &amp;i.LastName,
                        &amp;i.Status,
                        &amp;i.StatusReason,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.LastLoginAt,
                        &amp;i.VerifiedAt,
                        &amp;i.VerificationToken,
                        &amp;i.ResetToken,
                        &amp;i.ResetTokenExpiresAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const resetUserPassword = `-- name: ResetUserPassword :one
UPDATE users
SET
  password_hash = $2,
  reset_token = NULL,
  reset_token_expires_at = NULL,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at
`

type ResetUserPasswordParams struct {
        ID           pgtype.UUID `json:"id"`
        PasswordHash string      `json:"password_hash"`
}

func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, resetUserPassword, arg.ID, arg.PasswordHash)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const setPasswordResetToken = `-- name: SetPasswordResetToken :exec
UPDATE users
SET
  reset_token = $2,
  reset_token_expires_at = $3,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type SetPasswordResetTokenParams struct {
        ID                  pgtype.UUID        `json:"id"`
        ResetToken          pgtype.Text        `json:"reset_token"`
        ResetTokenExpiresAt pgtype.Timestamptz `json:"reset_token_expires_at"`
}

func (q *Queries) SetPasswordResetToken(ctx context.Context, arg SetPasswordResetTokenParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, setPasswordResetToken, arg.ID, arg.ResetToken, arg.ResetTokenExpiresAt)
        return err
}</span>

const setVerificationToken = `-- name: SetVerificationToken :exec
UPDATE users
SET
  verification_token = $2,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type SetVerificationTokenParams struct {
        ID                pgtype.UUID `json:"id"`
        VerificationToken pgtype.Text `json:"verification_token"`
}

func (q *Queries) SetVerificationToken(ctx context.Context, arg SetVerificationTokenParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, setVerificationToken, arg.ID, arg.VerificationToken)
        return err
}</span>

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
  first_name = COALESCE($2, first_name),
  last_name = COALESCE($3, last_name),
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at
`

type UpdateUserParams struct {
        ID        pgtype.UUID `json:"id"`
        FirstName pgtype.Text `json:"first_name"`
        LastName  pgtype.Text `json:"last_name"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.FirstName, arg.LastName)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateUserLastLogin, id)
        return err
}</span>

const updateUserStatus = `-- name: UpdateUserStatus :one
UPDATE users
SET
  status = $2,
  status_reason = $3,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at
`

type UpdateUserStatusParams struct {
        ID           pgtype.UUID `json:"id"`
        Status       UserStatus  `json:"status"`
        StatusReason pgtype.Text `json:"status_reason"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateUserStatus, arg.ID, arg.Status, arg.StatusReason)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET
  verified_at = CURRENT_TIMESTAMP,
  verification_token = NULL,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, email, username, password_hash, first_name, last_name, status, status_reason, created_at, updated_at, last_login_at, verified_at, verification_token, reset_token, reset_token_expires_at
`

func (q *Queries) VerifyUserEmail(ctx context.Context, id pgtype.UUID) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, verifyUserEmail, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Status,
                &amp;i.StatusReason,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.VerifiedAt,
                &amp;i.VerificationToken,
                &amp;i.ResetToken,
                &amp;i.ResetTokenExpiresAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package email

import (
        "fmt"
        "log/slog"

        "github.com/keighl/postmark"
)

// EmailService defines the interface for sending emails
type EmailService interface {
        SendVerificationEmail(to, token string) error
        SendPasswordResetEmail(to, token string) error
}

// EmailConfig holds configuration for email services
type EmailConfig struct {
        Provider        string // "mock" or "postmark"
        PostmarkToken   string
        PostmarkAccount string
        FromAddress     string
        FromName        string
        VerifyBaseURL   string
}

// NewEmailService creates an email service based on the provider configuration
func NewEmailService(logger *slog.Logger, config EmailConfig) EmailService <span class="cov0" title="0">{
        switch config.Provider </span>{
        case "postmark":<span class="cov0" title="0">
                return newPostmarkEmailService(logger, config)</span>
        default:<span class="cov0" title="0">
                return newMockEmailService(logger, config)</span>
        }
}

// mockEmailService is a mock implementation that logs instead of sending emails
type mockEmailService struct {
        logger *slog.Logger
        config EmailConfig
}

// newMockEmailService creates a new mock email service
func newMockEmailService(logger *slog.Logger, config EmailConfig) *mockEmailService <span class="cov0" title="0">{
        return &amp;mockEmailService{
                logger: logger,
                config: config,
        }
}</span>

// SendVerificationEmail logs the verification email instead of sending it
func (s *mockEmailService) SendVerificationEmail(to, token string) error <span class="cov0" title="0">{
        verifyURL := fmt.Sprintf("%s/verify?token=%s", s.config.VerifyBaseURL, token)
        s.logger.Info("ðŸ“§ MOCK EMAIL: Verification email",
                slog.String("to", to),
                slog.String("token", token),
                slog.String("verify_url", verifyURL),
        )
        return nil
}</span>

// SendPasswordResetEmail logs the password reset email instead of sending it
func (s *mockEmailService) SendPasswordResetEmail(to, token string) error <span class="cov0" title="0">{
        resetURL := fmt.Sprintf("%s/reset-password?token=%s", s.config.VerifyBaseURL, token)
        s.logger.Info("ðŸ“§ MOCK EMAIL: Password reset email",
                slog.String("to", to),
                slog.String("token", token),
                slog.String("reset_url", resetURL),
        )
        return nil
}</span>

// postmarkEmailService sends emails via Postmark
type postmarkEmailService struct {
        client *postmark.Client
        logger *slog.Logger
        config EmailConfig
}

// newPostmarkEmailService creates a new Postmark email service
func newPostmarkEmailService(logger *slog.Logger, config EmailConfig) *postmarkEmailService <span class="cov0" title="0">{
        client := postmark.NewClient(config.PostmarkToken, config.PostmarkAccount)
        return &amp;postmarkEmailService{
                client: client,
                logger: logger,
                config: config,
        }
}</span>

// SendVerificationEmail sends a verification email via Postmark
func (s *postmarkEmailService) SendVerificationEmail(to, token string) error <span class="cov0" title="0">{
        verifyURL := fmt.Sprintf("%s/verify?token=%s", s.config.VerifyBaseURL, token)

        email := postmark.Email{
                From:     fmt.Sprintf("%s &lt;%s&gt;", s.config.FromName, s.config.FromAddress),
                To:       to,
                Subject:  "Verify your email address",
                TextBody: fmt.Sprintf("Please verify your email address by clicking this link: %s", verifyURL),
                HtmlBody: fmt.Sprintf(`
                        &lt;h2&gt;Verify your email address&lt;/h2&gt;
                        &lt;p&gt;Thank you for registering with Aletheia. Please verify your email address by clicking the link below:&lt;/p&gt;
                        &lt;p&gt;&lt;a href="%s"&gt;Verify Email Address&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;Or copy and paste this URL into your browser:&lt;/p&gt;
                        &lt;p&gt;%s&lt;/p&gt;
                        &lt;p&gt;This link will expire in 24 hours.&lt;/p&gt;
                `, verifyURL, verifyURL),
                Tag:        "email-verification",
                TrackOpens: true,
        }

        _, err := s.client.SendEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to send verification email via Postmark",
                        slog.String("to", to),
                        slog.String("error", err.Error()),
                )
                return fmt.Errorf("failed to send verification email: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("verification email sent via Postmark",
                slog.String("to", to),
        )
        return nil</span>
}

// SendPasswordResetEmail sends a password reset email via Postmark
func (s *postmarkEmailService) SendPasswordResetEmail(to, token string) error <span class="cov0" title="0">{
        resetURL := fmt.Sprintf("%s/reset-password?token=%s", s.config.VerifyBaseURL, token)

        email := postmark.Email{
                From:     fmt.Sprintf("%s &lt;%s&gt;", s.config.FromName, s.config.FromAddress),
                To:       to,
                Subject:  "Reset your password",
                TextBody: fmt.Sprintf("Reset your password by clicking this link: %s", resetURL),
                HtmlBody: fmt.Sprintf(`
                        &lt;h2&gt;Reset your password&lt;/h2&gt;
                        &lt;p&gt;We received a request to reset your password. Click the link below to reset it:&lt;/p&gt;
                        &lt;p&gt;&lt;a href="%s"&gt;Reset Password&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;Or copy and paste this URL into your browser:&lt;/p&gt;
                        &lt;p&gt;%s&lt;/p&gt;
                        &lt;p&gt;If you didn't request this, you can safely ignore this email.&lt;/p&gt;
                        &lt;p&gt;This link will expire in 1 hour.&lt;/p&gt;
                `, resetURL, resetURL),
                Tag:        "password-reset",
                TrackOpens: true,
        }

        _, err := s.client.SendEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to send password reset email via Postmark",
                        slog.String("to", to),
                        slog.String("error", err.Error()),
                )
                return fmt.Errorf("failed to send password reset email: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("password reset email sent via Postmark",
                slog.String("to", to),
        )
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "log/slog"
        "net/http"
        "time"

        "github.com/dukerupert/aletheia/internal/auth"
        "github.com/dukerupert/aletheia/internal/database"
        "github.com/dukerupert/aletheia/internal/email"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

type AuthHandler struct {
        db           *pgxpool.Pool
        logger       *slog.Logger
        emailService email.EmailService
}

func NewAuthHandler(db *pgxpool.Pool, logger *slog.Logger, emailService email.EmailService) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                db:           db,
                logger:       logger,
                emailService: emailService,
        }
}</span>

type RegisterRequest struct {
        Email     string `json:"email" validate:"required,email"`
        Username  string `json:"username" validate:"required,min=3,max=50"`
        Password  string `json:"password" validate:"required,min=8"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
}

type RegisterResponse struct {
        ID       string `json:"id"`
        Email    string `json:"email"`
        Username string `json:"username"`
}

// Register handles user registration
func (h *AuthHandler) Register(c echo.Context) error <span class="cov8" title="1">{
        var req RegisterRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        // Validate request
        <span class="cov8" title="1">if req.Email == "" || req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "email, username, and password are required")
        }</span>

        <span class="cov8" title="1">if len(req.Password) &lt; 8 </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "password must be at least 8 characters")
        }</span>

        // Hash password
        <span class="cov8" title="1">passwordHash, err := auth.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to hash password", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to process password")
        }</span>

        // Create user in database
        <span class="cov8" title="1">queries := database.New(h.db)

        // Convert optional fields to pgtype.Text
        var firstName, lastName pgtype.Text
        if req.FirstName != "" </span><span class="cov8" title="1">{
                firstName = pgtype.Text{String: req.FirstName, Valid: true}
        }</span>
        <span class="cov8" title="1">if req.LastName != "" </span><span class="cov8" title="1">{
                lastName = pgtype.Text{String: req.LastName, Valid: true}
        }</span>

        <span class="cov8" title="1">user, err := queries.CreateUser(c.Request().Context(), database.CreateUserParams{
                Email:        req.Email,
                Username:     req.Username,
                PasswordHash: passwordHash,
                FirstName:    firstName,
                LastName:     lastName,
        })

        if err != nil </span><span class="cov8" title="1">{
                // Check for unique constraint violation
                if err.Error() == "ERROR: duplicate key value violates unique constraint \"users_email_key\" (SQLSTATE 23505)" ||
                        err.Error() == "ERROR: duplicate key value violates unique constraint \"users_username_key\" (SQLSTATE 23505)" </span><span class="cov8" title="1">{
                        h.logger.Warn("registration attempt with existing email/username",
                                slog.String("email", req.Email),
                                slog.String("username", req.Username),
                        )
                        return echo.NewHTTPError(http.StatusConflict, "email or username already exists")
                }</span>

                <span class="cov0" title="0">h.logger.Error("failed to create user", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create user")</span>
        }

        // Generate verification token
        <span class="cov8" title="1">verificationToken, err := auth.GenerateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to generate verification token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create user")
        }</span>

        // Save verification token to database
        <span class="cov8" title="1">if err := queries.SetVerificationToken(c.Request().Context(), database.SetVerificationTokenParams{
                ID:                user.ID,
                VerificationToken: pgtype.Text{String: verificationToken, Valid: true},
        }); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to set verification token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create user")
        }</span>

        // Send verification email
        <span class="cov8" title="1">if err := h.emailService.SendVerificationEmail(user.Email, verificationToken); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to send verification email",
                        slog.String("user_id", user.ID.String()),
                        slog.String("err", err.Error()),
                )
                // Don't fail registration if email fails - user can request resend
        }</span>

        <span class="cov8" title="1">h.logger.Info("user registered successfully",
                slog.String("user_id", user.ID.String()),
                slog.String("email", user.Email),
                slog.String("username", user.Username),
        )

        // Return user info (without password hash)
        return c.JSON(http.StatusCreated, RegisterResponse{
                ID:       user.ID.String(),
                Email:    user.Email,
                Username: user.Username,
        })</span>
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type LoginResponse struct {
        ID       string `json:"id"`
        Email    string `json:"email"`
        Username string `json:"username"`
}

// Login handles user login
func (h *AuthHandler) Login(c echo.Context) error <span class="cov8" title="1">{
        var req LoginRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        // Validate request
        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "email and password are required")
        }</span>

        // Get user by email
        <span class="cov8" title="1">queries := database.New(h.db)
        user, err := queries.GetUserByEmail(c.Request().Context(), req.Email)
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        h.logger.Warn("login attempt with non-existent email", slog.String("email", req.Email))
                        return echo.NewHTTPError(http.StatusUnauthorized, "invalid email or password")
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get user", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "login failed")</span>
        }

        // Verify password
        <span class="cov8" title="1">if err := auth.VerifyPassword(req.Password, user.PasswordHash); err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("login attempt with invalid password",
                        slog.String("user_id", user.ID.String()),
                        slog.String("email", user.Email),
                )
                return echo.NewHTTPError(http.StatusUnauthorized, "invalid email or password")
        }</span>

        // Check if user is active
        <span class="cov8" title="1">if user.Status != "active" </span><span class="cov0" title="0">{
                h.logger.Warn("login attempt for non-active user",
                        slog.String("user_id", user.ID.String()),
                        slog.String("status", string(user.Status)),
                )
                return echo.NewHTTPError(http.StatusForbidden, "account is not active")
        }</span>

        // Create session (convert pgtype.UUID to uuid.UUID)
        <span class="cov8" title="1">sess, err := session.CreateSession(c.Request().Context(), h.db, user.ID.Bytes, session.SessionDuration)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create session", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "login failed")
        }</span>

        // Update last login time
        <span class="cov8" title="1">if err := queries.UpdateUserLastLogin(c.Request().Context(), user.ID); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("failed to update last login time", slog.String("err", err.Error()))
                // Don't fail the login for this
        }</span>

        // Set session cookie
        <span class="cov8" title="1">cookie := &amp;http.Cookie{
                Name:     session.SessionCookieName,
                Value:    sess.Token,
                Path:     "/",
                HttpOnly: true,
                Secure:   c.Request().URL.Scheme == "https", // Only send over HTTPS in production
                SameSite: http.SameSiteLaxMode,
                Expires:  sess.ExpiresAt.Time, // Convert pgtype.Timestamptz to time.Time
        }
        c.SetCookie(cookie)

        h.logger.Info("user logged in successfully",
                slog.String("user_id", user.ID.String()),
                slog.String("email", user.Email),
        )

        // Return user info
        return c.JSON(http.StatusOK, LoginResponse{
                ID:       user.ID.String(),
                Email:    user.Email,
                Username: user.Username,
        })</span>
}

// Logout handles user logout
func (h *AuthHandler) Logout(c echo.Context) error <span class="cov8" title="1">{
        // Get session token from cookie
        cookie, err := c.Cookie(session.SessionCookieName)
        if err != nil </span><span class="cov8" title="1">{
                // No session cookie found
                return echo.NewHTTPError(http.StatusBadRequest, "not logged in")
        }</span>

        // Delete session from database
        <span class="cov8" title="1">if err := session.DestroySession(c.Request().Context(), h.db, cookie.Value); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to destroy session", slog.String("err", err.Error()))
                // Continue to clear cookie even if database delete fails
        }</span>

        // Clear session cookie
        <span class="cov8" title="1">cookie = &amp;http.Cookie{
                Name:     session.SessionCookieName,
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                MaxAge:   -1, // Delete cookie
        }
        c.SetCookie(cookie)

        h.logger.Info("user logged out successfully")

        return c.JSON(http.StatusOK, map[string]string{
                "message": "logged out successfully",
        })</span>
}

// Me returns the current authenticated user's information
func (h *AuthHandler) Me(c echo.Context) error <span class="cov8" title="1">{
        // Get user ID from context (set by session middleware)
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusUnauthorized, "authentication required")
        }</span>

        // Get user from database
        <span class="cov8" title="1">queries := database.New(h.db)
        user, err := queries.GetUser(c.Request().Context(), pgtype.UUID{
                Bytes: userID,
                Valid: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to get user")
        }</span>

        // Return user info
        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]interface{}{
                "id":         user.ID.String(),
                "email":      user.Email,
                "username":   user.Username,
                "first_name": user.FirstName,
                "last_name":  user.LastName,
                "status":     user.Status,
        })</span>
}

type UpdateProfileRequest struct {
        FirstName *string `json:"first_name"`
        LastName  *string `json:"last_name"`
}

type UpdateProfileResponse struct {
        ID        string `json:"id"`
        Email     string `json:"email"`
        Username  string `json:"username"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
}

// UpdateProfile updates the current user's profile information
func (h *AuthHandler) UpdateProfile(c echo.Context) error <span class="cov8" title="1">{
        // Get user ID from context (set by session middleware)
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusUnauthorized, "authentication required")
        }</span>

        <span class="cov8" title="1">var req UpdateProfileRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        // Build update parameters
        <span class="cov8" title="1">queries := database.New(h.db)

        // Convert to pgtype.Text for nullable fields
        var firstName, lastName pgtype.Text
        if req.FirstName != nil </span><span class="cov8" title="1">{
                firstName = pgtype.Text{String: *req.FirstName, Valid: true}
        }</span>
        <span class="cov8" title="1">if req.LastName != nil </span><span class="cov8" title="1">{
                lastName = pgtype.Text{String: *req.LastName, Valid: true}
        }</span>

        // Update user
        <span class="cov8" title="1">user, err := queries.UpdateUser(c.Request().Context(), database.UpdateUserParams{
                ID:        pgtype.UUID{Bytes: userID, Valid: true},
                FirstName: firstName,
                LastName:  lastName,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to update user", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to update profile")
        }</span>

        <span class="cov8" title="1">h.logger.Info("user profile updated",
                slog.String("user_id", user.ID.String()),
                slog.String("email", user.Email),
        )

        // Return updated user info
        resp := UpdateProfileResponse{
                ID:       user.ID.String(),
                Email:    user.Email,
                Username: user.Username,
        }

        if user.FirstName.Valid </span><span class="cov8" title="1">{
                resp.FirstName = user.FirstName.String
        }</span>
        <span class="cov8" title="1">if user.LastName.Valid </span><span class="cov8" title="1">{
                resp.LastName = user.LastName.String
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, resp)</span>
}

type VerifyEmailRequest struct {
        Token string `json:"token" validate:"required"`
}

// VerifyEmail verifies a user's email address using the verification token
func (h *AuthHandler) VerifyEmail(c echo.Context) error <span class="cov8" title="1">{
        var req VerifyEmailRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Token == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "verification token is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.db)

        // Find user by verification token
        user, err := queries.GetUserByVerificationToken(c.Request().Context(), pgtype.Text{
                String: req.Token,
                Valid:  true,
        })
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        h.logger.Warn("verification attempt with invalid token", slog.String("token", req.Token))
                        return echo.NewHTTPError(http.StatusBadRequest, "invalid or expired verification token")
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get user by verification token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "verification failed")</span>
        }

        // Verify the user's email
        <span class="cov8" title="1">verifiedUser, err := queries.VerifyUserEmail(c.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to verify user email", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "verification failed")
        }</span>

        <span class="cov8" title="1">h.logger.Info("user email verified successfully",
                slog.String("user_id", verifiedUser.ID.String()),
                slog.String("email", verifiedUser.Email),
        )

        return c.JSON(http.StatusOK, map[string]string{
                "message": "email verified successfully",
        })</span>
}

type ResendVerificationRequest struct {
        Email string `json:"email" validate:"required,email"`
}

// ResendVerification resends the verification email to a user
func (h *AuthHandler) ResendVerification(c echo.Context) error <span class="cov8" title="1">{
        var req ResendVerificationRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Email == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "email is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.db)

        // Get user by email
        user, err := queries.GetUserByEmail(c.Request().Context(), req.Email)
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        // Don't reveal if email exists or not for security
                        h.logger.Warn("resend verification attempt for non-existent email", slog.String("email", req.Email))
                        return c.JSON(http.StatusOK, map[string]string{
                                "message": "if that email exists and is not verified, a verification email has been sent",
                        })
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get user", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to resend verification email")</span>
        }

        // Check if user is already verified
        <span class="cov8" title="1">if user.VerifiedAt.Valid </span><span class="cov8" title="1">{
                h.logger.Info("resend verification attempt for already verified user",
                        slog.String("user_id", user.ID.String()),
                        slog.String("email", user.Email),
                )
                return c.JSON(http.StatusOK, map[string]string{
                        "message": "if that email exists and is not verified, a verification email has been sent",
                })
        }</span>

        // Generate new verification token
        <span class="cov8" title="1">verificationToken, err := auth.GenerateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to generate verification token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to resend verification email")
        }</span>

        // Save verification token to database
        <span class="cov8" title="1">if err := queries.SetVerificationToken(c.Request().Context(), database.SetVerificationTokenParams{
                ID:                user.ID,
                VerificationToken: pgtype.Text{String: verificationToken, Valid: true},
        }); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to set verification token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to resend verification email")
        }</span>

        // Send verification email
        <span class="cov8" title="1">if err := h.emailService.SendVerificationEmail(user.Email, verificationToken); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to send verification email",
                        slog.String("user_id", user.ID.String()),
                        slog.String("err", err.Error()),
                )
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to send verification email")
        }</span>

        <span class="cov8" title="1">h.logger.Info("verification email resent",
                slog.String("user_id", user.ID.String()),
                slog.String("email", user.Email),
        )

        return c.JSON(http.StatusOK, map[string]string{
                "message": "if that email exists and is not verified, a verification email has been sent",
        })</span>
}

type RequestPasswordResetRequest struct {
        Email string `json:"email" validate:"required,email"`
}

// RequestPasswordReset initiates the password reset flow
func (h *AuthHandler) RequestPasswordReset(c echo.Context) error <span class="cov8" title="1">{
        var req RequestPasswordResetRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Email == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "email is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.db)

        // Get user by email
        user, err := queries.GetUserByEmail(c.Request().Context(), req.Email)
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        // Don't reveal if email exists or not for security
                        h.logger.Warn("password reset attempt for non-existent email", slog.String("email", req.Email))
                        return c.JSON(http.StatusOK, map[string]string{
                                "message": "if that email exists, a password reset link has been sent",
                        })
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get user", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to request password reset")</span>
        }

        // Generate reset token
        <span class="cov8" title="1">resetToken, err := auth.GenerateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to generate reset token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to request password reset")
        }</span>

        // Set token expiration to 1 hour from now
        <span class="cov8" title="1">expiresAt := pgtype.Timestamptz{
                Time:  time.Now().Add(1 * time.Hour),
                Valid: true,
        }

        // Save reset token to database
        if err := queries.SetPasswordResetToken(c.Request().Context(), database.SetPasswordResetTokenParams{
                ID:                    user.ID,
                ResetToken:            pgtype.Text{String: resetToken, Valid: true},
                ResetTokenExpiresAt:   expiresAt,
        }); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to set reset token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to request password reset")
        }</span>

        // Send password reset email
        <span class="cov8" title="1">if err := h.emailService.SendPasswordResetEmail(user.Email, resetToken); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to send password reset email",
                        slog.String("user_id", user.ID.String()),
                        slog.String("err", err.Error()),
                )
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to send password reset email")
        }</span>

        <span class="cov8" title="1">h.logger.Info("password reset email sent",
                slog.String("user_id", user.ID.String()),
                slog.String("email", user.Email),
        )

        return c.JSON(http.StatusOK, map[string]string{
                "message": "if that email exists, a password reset link has been sent",
        })</span>
}

type VerifyResetTokenRequest struct {
        Token string `json:"token" validate:"required"`
}

// VerifyResetToken verifies that a password reset token is valid
func (h *AuthHandler) VerifyResetToken(c echo.Context) error <span class="cov8" title="1">{
        var req VerifyResetTokenRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Token == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "reset token is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.db)

        // Find user by reset token
        user, err := queries.GetUserByResetToken(c.Request().Context(), pgtype.Text{
                String: req.Token,
                Valid:  true,
        })
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        h.logger.Warn("reset token verification failed", slog.String("token", req.Token))
                        return echo.NewHTTPError(http.StatusBadRequest, "invalid or expired reset token")
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get user by reset token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "token verification failed")</span>
        }

        <span class="cov8" title="1">h.logger.Info("reset token verified",
                slog.String("user_id", user.ID.String()),
                slog.String("email", user.Email),
        )

        return c.JSON(http.StatusOK, map[string]string{
                "message": "reset token is valid",
        })</span>
}

type ResetPasswordRequest struct {
        Token       string `json:"token" validate:"required"`
        NewPassword string `json:"new_password" validate:"required,min=8"`
}

// ResetPassword resets a user's password using a valid reset token
func (h *AuthHandler) ResetPassword(c echo.Context) error <span class="cov8" title="1">{
        var req ResetPasswordRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to bind request", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Token == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "reset token is required")
        }</span>

        <span class="cov8" title="1">if len(req.NewPassword) &lt; 8 </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "password must be at least 8 characters")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.db)

        // Find user by reset token
        user, err := queries.GetUserByResetToken(c.Request().Context(), pgtype.Text{
                String: req.Token,
                Valid:  true,
        })
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        h.logger.Warn("password reset attempt with invalid token", slog.String("token", req.Token))
                        return echo.NewHTTPError(http.StatusBadRequest, "invalid or expired reset token")
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get user by reset token", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "password reset failed")</span>
        }

        // Hash new password
        <span class="cov8" title="1">passwordHash, err := auth.HashPassword(req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to hash password", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to process password")
        }</span>

        // Reset password and clear reset token
        <span class="cov8" title="1">updatedUser, err := queries.ResetUserPassword(c.Request().Context(), database.ResetUserPasswordParams{
                ID:           user.ID,
                PasswordHash: passwordHash,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to reset password", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "password reset failed")
        }</span>

        <span class="cov8" title="1">h.logger.Info("password reset successfully",
                slog.String("user_id", updatedUser.ID.String()),
                slog.String("email", updatedUser.Email),
        )

        return c.JSON(http.StatusOK, map[string]string{
                "message": "password reset successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

// parseUUID converts a string UUID to pgtype.UUID
func parseUUID(s string) (pgtype.UUID, error) <span class="cov8" title="1">{
        var pguuid pgtype.UUID
        err := pguuid.Scan(s)
        return pguuid, err
}</span>

// uuidToPgUUID converts a uuid.UUID to pgtype.UUID
func uuidToPgUUID(u uuid.UUID) pgtype.UUID <span class="cov8" title="1">{
        return pgtype.UUID{
                Bytes: u,
                Valid: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package handlers

import (
        "log/slog"
        "net/http"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

type InspectionHandler struct {
        pool   *pgxpool.Pool
        logger *slog.Logger
}

func NewInspectionHandler(pool *pgxpool.Pool, logger *slog.Logger) *InspectionHandler <span class="cov8" title="1">{
        return &amp;InspectionHandler{
                pool:   pool,
                logger: logger,
        }
}</span>

// CreateInspectionRequest is the request payload for creating an inspection
type CreateInspectionRequest struct {
        ProjectID string `json:"project_id" validate:"required"`
}

// CreateInspectionResponse is the response payload for inspection creation
type CreateInspectionResponse struct {
        ID          string `json:"id"`
        ProjectID   string `json:"project_id"`
        InspectorID string `json:"inspector_id"`
        Status      string `json:"status"`
        CreatedAt   string `json:"created_at"`
}

// CreateInspection creates a new inspection for a project
func (h *InspectionHandler) CreateInspection(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req CreateInspectionRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.ProjectID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "project_id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse project ID
        projectUUID, err := parseUUID(req.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid project_id")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "project not found")
        }</span>

        // Verify user is a member of the organization that owns this project
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("user not authorized to create inspection in project",
                        slog.String("user_id", userID.String()),
                        slog.String("project_id", req.ProjectID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this project's organization")
        }</span>

        // Create inspection with default status 'draft'
        <span class="cov8" title="1">inspection, err := queries.CreateInspection(c.Request().Context(), database.CreateInspectionParams{
                ProjectID:    projectUUID,
                InspectorID:  uuidToPgUUID(userID),
                Status:       database.InspectionStatusDraft,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create inspection")
        }</span>

        <span class="cov8" title="1">h.logger.Info("inspection created",
                slog.String("inspection_id", inspection.ID.String()),
                slog.String("project_id", req.ProjectID),
                slog.String("inspector_id", userID.String()))

        return c.JSON(http.StatusCreated, CreateInspectionResponse{
                ID:          inspection.ID.String(),
                ProjectID:   inspection.ProjectID.String(),
                InspectorID: inspection.InspectorID.String(),
                Status:      string(inspection.Status),
                CreatedAt:   inspection.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// GetInspectionResponse is the response payload for inspection retrieval
type GetInspectionResponse struct {
        ID          string `json:"id"`
        ProjectID   string `json:"project_id"`
        InspectorID string `json:"inspector_id"`
        Status      string `json:"status"`
        CreatedAt   string `json:"created_at"`
        UpdatedAt   string `json:"updated_at"`
}

// GetInspection retrieves an inspection by ID
func (h *InspectionHandler) GetInspection(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">inspectionID := c.Param("id")
        if inspectionID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "inspection id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse inspection ID
        inspectionUUID, err := parseUUID(inspectionID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid inspection id")
        }</span>

        // Get inspection
        <span class="cov8" title="1">inspection, err := queries.GetInspection(c.Request().Context(), inspectionUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusNotFound, "inspection not found")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), inspection.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project for inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to get inspection details")
        }</span>

        // Verify user is a member of the organization that owns this project
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to access inspection",
                        slog.String("user_id", userID.String()),
                        slog.String("inspection_id", inspectionID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this inspection's organization")
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, GetInspectionResponse{
                ID:          inspection.ID.String(),
                ProjectID:   inspection.ProjectID.String(),
                InspectorID: inspection.InspectorID.String(),
                Status:      string(inspection.Status),
                CreatedAt:   inspection.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:   inspection.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// ListInspectionsResponse is the response payload for listing inspections
type InspectionSummary struct {
        ID          string `json:"id"`
        ProjectID   string `json:"project_id"`
        InspectorID string `json:"inspector_id"`
        Status      string `json:"status"`
        CreatedAt   string `json:"created_at"`
}

type ListInspectionsResponse struct {
        Inspections []InspectionSummary `json:"inspections"`
}

// ListInspections lists all inspections for a project
func (h *InspectionHandler) ListInspections(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">projectID := c.Param("projectId")
        if projectID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "project id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse project ID
        projectUUID, err := parseUUID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid project id")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "project not found")
        }</span>

        // Verify user is a member of the organization
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to list inspections in project",
                        slog.String("user_id", userID.String()),
                        slog.String("project_id", projectID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this project's organization")
        }</span>

        // Get all inspections for the project
        <span class="cov8" title="1">inspections, err := queries.ListInspections(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list inspections", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to list inspections")
        }</span>

        <span class="cov8" title="1">inspectionSummaries := make([]InspectionSummary, len(inspections))
        for i, inspection := range inspections </span><span class="cov8" title="1">{
                inspectionSummaries[i] = InspectionSummary{
                        ID:          inspection.ID.String(),
                        ProjectID:   inspection.ProjectID.String(),
                        InspectorID: inspection.InspectorID.String(),
                        Status:      string(inspection.Status),
                        CreatedAt:   inspection.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, ListInspectionsResponse{
                Inspections: inspectionSummaries,
        })</span>
}

// UpdateInspectionStatusRequest is the request payload for updating inspection status
type UpdateInspectionStatusRequest struct {
        Status string `json:"status" validate:"required,oneof=draft in_progress completed"`
}

// UpdateInspectionStatusResponse is the response payload for status update
type UpdateInspectionStatusResponse struct {
        ID        string `json:"id"`
        Status    string `json:"status"`
        UpdatedAt string `json:"updated_at"`
}

// UpdateInspectionStatus updates an inspection's status
func (h *InspectionHandler) UpdateInspectionStatus(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">inspectionID := c.Param("id")
        if inspectionID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "inspection id is required")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req UpdateInspectionStatusRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Status == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "status is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse inspection ID
        inspectionUUID, err := parseUUID(inspectionID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid inspection id")
        }</span>

        // Get inspection
        <span class="cov8" title="1">inspection, err := queries.GetInspection(c.Request().Context(), inspectionUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "inspection not found")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), inspection.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project for inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to get inspection details")
        }</span>

        // Verify user is the inspector or an owner/admin of the organization
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to update inspection",
                        slog.String("user_id", userID.String()),
                        slog.String("inspection_id", inspectionID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this inspection's organization")
        }</span>

        // Check if user is the inspector or an owner/admin
        <span class="cov8" title="1">isInspector := inspection.InspectorID.Bytes == userID
        isOwnerOrAdmin := membership.Role == database.OrganizationRoleOwner || membership.Role == database.OrganizationRoleAdmin

        if !isInspector &amp;&amp; !isOwnerOrAdmin </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusForbidden, "only the inspector or organization owners/admins can update inspection status")
        }</span>

        // Parse and validate new status
        <span class="cov8" title="1">var newStatus database.InspectionStatus
        switch req.Status </span>{
        case "draft":<span class="cov0" title="0">
                newStatus = database.InspectionStatusDraft</span>
        case "in_progress":<span class="cov8" title="1">
                newStatus = database.InspectionStatusInProgress</span>
        case "completed":<span class="cov0" title="0">
                newStatus = database.InspectionStatusCompleted</span>
        default:<span class="cov0" title="0">
                return echo.NewHTTPError(http.StatusBadRequest, "invalid status")</span>
        }

        // Update inspection status
        <span class="cov8" title="1">updatedInspection, err := queries.UpdateInspectionStatus(c.Request().Context(), database.UpdateInspectionStatusParams{
                ID:     inspectionUUID,
                Status: newStatus,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to update inspection status", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to update inspection status")
        }</span>

        <span class="cov8" title="1">h.logger.Info("inspection status updated",
                slog.String("inspection_id", inspectionID),
                slog.String("new_status", req.Status))

        return c.JSON(http.StatusOK, UpdateInspectionStatusResponse{
                ID:        updatedInspection.ID.String(),
                Status:    string(updatedInspection.Status),
                UpdatedAt: updatedInspection.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "log/slog"
        "net/http"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

type OrganizationHandler struct {
        pool   *pgxpool.Pool
        logger *slog.Logger
}

func NewOrganizationHandler(pool *pgxpool.Pool, logger *slog.Logger) *OrganizationHandler <span class="cov8" title="1">{
        return &amp;OrganizationHandler{
                pool:   pool,
                logger: logger,
        }
}</span>

// CreateOrganizationRequest is the request payload for creating an organization
type CreateOrganizationRequest struct {
        Name string `json:"name" validate:"required,min=1,max=255"`
}

// CreateOrganizationResponse is the response payload for organization creation
type CreateOrganizationResponse struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        CreatedAt string `json:"created_at"`
}

// CreateOrganization creates a new organization and adds the creating user as owner
func (h *OrganizationHandler) CreateOrganization(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req CreateOrganizationRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Name == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization name is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Create organization
        org, err := queries.CreateOrganization(c.Request().Context(), req.Name)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create organization", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create organization")
        }</span>

        // Add creator as owner
        <span class="cov8" title="1">_, err = queries.AddOrganizationMember(c.Request().Context(), database.AddOrganizationMemberParams{
                OrganizationID: org.ID,
                UserID:         uuidToPgUUID(userID),
                Role:           database.OrganizationRoleOwner,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to add organization owner", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create organization")
        }</span>

        <span class="cov8" title="1">h.logger.Info("organization created", slog.String("org_id", org.ID.String()), slog.String("user_id", userID.String()))

        return c.JSON(http.StatusCreated, CreateOrganizationResponse{
                ID:        org.ID.String(),
                Name:      org.Name,
                CreatedAt: org.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// GetOrganizationResponse is the response payload for organization retrieval
type GetOrganizationResponse struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        CreatedAt string `json:"created_at"`
        UpdatedAt string `json:"updated_at"`
}

// GetOrganization retrieves an organization by ID
func (h *OrganizationHandler) GetOrganization(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        if orgID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        // Check if user is a member of the organization
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("user not authorized to access organization",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        // Get organization
        <span class="cov8" title="1">org, err := queries.GetOrganization(c.Request().Context(), orgUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get organization", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusNotFound, "organization not found")
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, GetOrganizationResponse{
                ID:        org.ID.String(),
                Name:      org.Name,
                CreatedAt: org.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt: org.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// ListOrganizationsResponse is the response payload for listing user's organizations
type OrganizationSummary struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        Role      string `json:"role"`
        CreatedAt string `json:"created_at"`
}

type ListOrganizationsResponse struct {
        Organizations []OrganizationSummary `json:"organizations"`
}

// ListOrganizations lists all organizations the authenticated user is a member of
func (h *OrganizationHandler) ListOrganizations(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Get all organization memberships for user
        memberships, err := queries.ListUserOrganizations(c.Request().Context(), uuidToPgUUID(userID))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list user organizations", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to list organizations")
        }</span>

        // Fetch organization details for each membership
        <span class="cov8" title="1">organizations := make([]OrganizationSummary, 0, len(memberships))
        for _, membership := range memberships </span><span class="cov8" title="1">{
                org, err := queries.GetOrganization(c.Request().Context(), membership.OrganizationID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn("failed to get organization for membership",
                                slog.String("org_id", membership.OrganizationID.String()),
                                slog.String("err", err.Error()))
                        continue</span>
                }

                <span class="cov8" title="1">organizations = append(organizations, OrganizationSummary{
                        ID:        org.ID.String(),
                        Name:      org.Name,
                        Role:      string(membership.Role),
                        CreatedAt: org.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                })</span>
        }

        <span class="cov8" title="1">return c.JSON(http.StatusOK, ListOrganizationsResponse{
                Organizations: organizations,
        })</span>
}

// UpdateOrganizationRequest is the request payload for updating an organization
type UpdateOrganizationRequest struct {
        Name *string `json:"name,omitempty" validate:"omitempty,min=1,max=255"`
}

// UpdateOrganizationResponse is the response payload for organization update
type UpdateOrganizationResponse struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        UpdatedAt string `json:"updated_at"`
}

// UpdateOrganization updates an organization (owner/admin only)
func (h *OrganizationHandler) UpdateOrganization(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        if orgID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id is required")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req UpdateOrganizationRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        // Check if user is owner or admin
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to update organization",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        <span class="cov8" title="1">if membership.Role != database.OrganizationRoleOwner &amp;&amp; membership.Role != database.OrganizationRoleAdmin </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can update organization")
        }</span>

        // Update organization
        <span class="cov8" title="1">params := database.UpdateOrganizationParams{
                ID: orgUUID,
        }

        if req.Name != nil </span><span class="cov8" title="1">{
                params.Name = *req.Name
        }</span>

        <span class="cov8" title="1">org, err := queries.UpdateOrganization(c.Request().Context(), params)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to update organization", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to update organization")
        }</span>

        <span class="cov8" title="1">h.logger.Info("organization updated", slog.String("org_id", org.ID.String()))

        return c.JSON(http.StatusOK, UpdateOrganizationResponse{
                ID:        org.ID.String(),
                Name:      org.Name,
                UpdatedAt: org.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// DeleteOrganization deletes an organization (owner only)
func (h *OrganizationHandler) DeleteOrganization(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        if orgID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        // Check if user is owner
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to delete organization",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        <span class="cov8" title="1">if membership.Role != database.OrganizationRoleOwner </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners can delete organization")
        }</span>

        // Delete organization
        <span class="cov8" title="1">err = queries.DeleteOrganization(c.Request().Context(), orgUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to delete organization", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to delete organization")
        }</span>

        <span class="cov8" title="1">h.logger.Info("organization deleted", slog.String("org_id", orgID))

        return c.NoContent(http.StatusNoContent)</span>
}

// ListOrganizationMembersResponse is the response payload for listing organization members
type MemberSummary struct {
        ID        string `json:"id"`
        UserID    string `json:"user_id"`
        Role      string `json:"role"`
        CreatedAt string `json:"created_at"`
}

type ListOrganizationMembersResponse struct {
        Members []MemberSummary `json:"members"`
}

// ListOrganizationMembers lists all members of an organization
func (h *OrganizationHandler) ListOrganizationMembers(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        if orgID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        // Check if user is a member of the organization
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to access organization members",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        // Get organization members
        <span class="cov8" title="1">members, err := queries.ListOrganizationMembers(c.Request().Context(), orgUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list organization members", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to list organization members")
        }</span>

        <span class="cov8" title="1">memberSummaries := make([]MemberSummary, len(members))
        for i, member := range members </span><span class="cov8" title="1">{
                memberSummaries[i] = MemberSummary{
                        ID:        member.ID.String(),
                        UserID:    member.UserID.String(),
                        Role:      string(member.Role),
                        CreatedAt: member.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, ListOrganizationMembersResponse{
                Members: memberSummaries,
        })</span>
}

// AddOrganizationMemberRequest is the request payload for adding a member
type AddOrganizationMemberRequest struct {
        Email string `json:"email" validate:"required,email"`
        Role  string `json:"role" validate:"required,oneof=admin member"`
}

// AddOrganizationMemberResponse is the response payload for adding a member
type AddOrganizationMemberResponse struct {
        ID        string `json:"id"`
        UserID    string `json:"user_id"`
        Role      string `json:"role"`
        CreatedAt string `json:"created_at"`
}

// AddOrganizationMember adds a new member to the organization (owner/admin only)
func (h *OrganizationHandler) AddOrganizationMember(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        if orgID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id is required")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req AddOrganizationMemberRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Email == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "email is required")
        }</span>

        <span class="cov8" title="1">if req.Role == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "role is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        // Check if requester is owner or admin
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to add organization member",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        <span class="cov8" title="1">if membership.Role != database.OrganizationRoleOwner &amp;&amp; membership.Role != database.OrganizationRoleAdmin </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can add members")
        }</span>

        // Find user by email
        <span class="cov8" title="1">targetUser, err := queries.GetUserByEmail(c.Request().Context(), req.Email)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not found for organization invite", slog.String("email", req.Email))
                return echo.NewHTTPError(http.StatusNotFound, "user not found")
        }</span>

        // Check if user is already a member
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         targetUser.ID,
        })
        if err == nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusConflict, "user is already a member of this organization")
        }</span>

        // Parse role
        <span class="cov8" title="1">var role database.OrganizationRole
        switch req.Role </span>{
        case "admin":<span class="cov0" title="0">
                role = database.OrganizationRoleAdmin</span>
        case "member":<span class="cov8" title="1">
                role = database.OrganizationRoleMember</span>
        default:<span class="cov0" title="0">
                return echo.NewHTTPError(http.StatusBadRequest, "invalid role")</span>
        }

        // Add member
        <span class="cov8" title="1">newMember, err := queries.AddOrganizationMember(c.Request().Context(), database.AddOrganizationMemberParams{
                OrganizationID: orgUUID,
                UserID:         targetUser.ID,
                Role:           role,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to add organization member", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to add organization member")
        }</span>

        <span class="cov8" title="1">h.logger.Info("organization member added",
                slog.String("org_id", orgID),
                slog.String("user_id", targetUser.ID.String()),
                slog.String("role", req.Role))

        return c.JSON(http.StatusCreated, AddOrganizationMemberResponse{
                ID:        newMember.ID.String(),
                UserID:    newMember.UserID.String(),
                Role:      string(newMember.Role),
                CreatedAt: newMember.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// UpdateOrganizationMemberRequest is the request payload for updating a member role
type UpdateOrganizationMemberRequest struct {
        Role string `json:"role" validate:"required,oneof=admin member"`
}

// UpdateOrganizationMemberResponse is the response payload for updating a member
type UpdateOrganizationMemberResponse struct {
        ID   string `json:"id"`
        Role string `json:"role"`
}

// UpdateOrganizationMember updates a member's role (owner/admin only)
func (h *OrganizationHandler) UpdateOrganizationMember(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        memberID := c.Param("memberId")
        if orgID == "" || memberID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id and member id are required")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req UpdateOrganizationMemberRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Role == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "role is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse IDs
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        <span class="cov8" title="1">memberUUID, err := parseUUID(memberID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid member id")
        }</span>

        // Check if requester is owner or admin
        <span class="cov8" title="1">requesterMembership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to update organization member",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        <span class="cov8" title="1">if requesterMembership.Role != database.OrganizationRoleOwner &amp;&amp; requesterMembership.Role != database.OrganizationRoleAdmin </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can update member roles")
        }</span>

        // Get the member being updated
        <span class="cov8" title="1">targetMember, err := queries.GetOrganizationMember(c.Request().Context(), memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "member not found")
        }</span>

        // Verify member belongs to this organization
        <span class="cov8" title="1">if targetMember.OrganizationID != orgUUID </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "member does not belong to this organization")
        }</span>

        // Prevent changing owner role
        <span class="cov8" title="1">if targetMember.Role == database.OrganizationRoleOwner </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "cannot change owner role")
        }</span>

        // Parse new role
        <span class="cov8" title="1">var role database.OrganizationRole
        switch req.Role </span>{
        case "admin":<span class="cov8" title="1">
                role = database.OrganizationRoleAdmin</span>
        case "member":<span class="cov0" title="0">
                role = database.OrganizationRoleMember</span>
        default:<span class="cov0" title="0">
                return echo.NewHTTPError(http.StatusBadRequest, "invalid role")</span>
        }

        // Update member role
        <span class="cov8" title="1">updatedMember, err := queries.UpdateOrganizationMemberRole(c.Request().Context(), database.UpdateOrganizationMemberRoleParams{
                ID:   memberUUID,
                Role: role,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to update organization member role", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to update member role")
        }</span>

        <span class="cov8" title="1">h.logger.Info("organization member role updated",
                slog.String("org_id", orgID),
                slog.String("member_id", memberID),
                slog.String("new_role", req.Role))

        return c.JSON(http.StatusOK, UpdateOrganizationMemberResponse{
                ID:   updatedMember.ID.String(),
                Role: string(updatedMember.Role),
        })</span>
}

// RemoveOrganizationMember removes a member from the organization (owner/admin only)
func (h *OrganizationHandler) RemoveOrganizationMember(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("id")
        memberID := c.Param("memberId")
        if orgID == "" || memberID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id and member id are required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse IDs
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        <span class="cov8" title="1">memberUUID, err := parseUUID(memberID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid member id")
        }</span>

        // Check if requester is owner or admin
        <span class="cov8" title="1">requesterMembership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to remove organization member",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        <span class="cov8" title="1">if requesterMembership.Role != database.OrganizationRoleOwner &amp;&amp; requesterMembership.Role != database.OrganizationRoleAdmin </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can remove members")
        }</span>

        // Get the member being removed
        <span class="cov8" title="1">targetMember, err := queries.GetOrganizationMember(c.Request().Context(), memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "member not found")
        }</span>

        // Verify member belongs to this organization
        <span class="cov8" title="1">if targetMember.OrganizationID != orgUUID </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "member does not belong to this organization")
        }</span>

        // Prevent removing owner
        <span class="cov8" title="1">if targetMember.Role == database.OrganizationRoleOwner </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "cannot remove owner")
        }</span>

        // Remove member
        <span class="cov8" title="1">err = queries.RemoveOrganizationMember(c.Request().Context(), memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to remove organization member", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to remove member")
        }</span>

        <span class="cov8" title="1">h.logger.Info("organization member removed",
                slog.String("org_id", orgID),
                slog.String("member_id", memberID))

        return c.NoContent(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handlers

import (
        "log/slog"
        "net/http"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

type ProjectHandler struct {
        pool   *pgxpool.Pool
        logger *slog.Logger
}

func NewProjectHandler(pool *pgxpool.Pool, logger *slog.Logger) *ProjectHandler <span class="cov8" title="1">{
        return &amp;ProjectHandler{
                pool:   pool,
                logger: logger,
        }
}</span>

// CreateProjectRequest is the request payload for creating a project
type CreateProjectRequest struct {
        OrganizationID string `json:"organization_id" validate:"required"`
        Name           string `json:"name" validate:"required,min=1,max=255"`
}

// CreateProjectResponse is the response payload for project creation
type CreateProjectResponse struct {
        ID             string `json:"id"`
        OrganizationID string `json:"organization_id"`
        Name           string `json:"name"`
        CreatedAt      string `json:"created_at"`
}

// CreateProject creates a new project within an organization (owner/admin only)
func (h *ProjectHandler) CreateProject(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req CreateProjectRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">if req.OrganizationID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization_id is required")
        }</span>

        <span class="cov8" title="1">if req.Name == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "project name is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(req.OrganizationID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization_id")
        }</span>

        // Verify user is owner or admin of the organization
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to create project in organization",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", req.OrganizationID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        <span class="cov8" title="1">if membership.Role != database.OrganizationRoleOwner &amp;&amp; membership.Role != database.OrganizationRoleAdmin </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can create projects")
        }</span>

        // Create project
        <span class="cov8" title="1">project, err := queries.CreateProject(c.Request().Context(), database.CreateProjectParams{
                OrganizationID: orgUUID,
                Name:           req.Name,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create project", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create project")
        }</span>

        <span class="cov8" title="1">h.logger.Info("project created",
                slog.String("project_id", project.ID.String()),
                slog.String("org_id", req.OrganizationID),
                slog.String("user_id", userID.String()))

        return c.JSON(http.StatusCreated, CreateProjectResponse{
                ID:             project.ID.String(),
                OrganizationID: project.OrganizationID.String(),
                Name:           project.Name,
                CreatedAt:      project.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// GetProjectResponse is the response payload for project retrieval
type GetProjectResponse struct {
        ID             string `json:"id"`
        OrganizationID string `json:"organization_id"`
        Name           string `json:"name"`
        CreatedAt      string `json:"created_at"`
        UpdatedAt      string `json:"updated_at"`
}

// GetProject retrieves a project by ID (organization members only)
func (h *ProjectHandler) GetProject(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">projectID := c.Param("id")
        if projectID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "project id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse project ID
        projectUUID, err := parseUUID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid project id")
        }</span>

        // Get project
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusNotFound, "project not found")
        }</span>

        // Verify user is a member of the organization that owns this project
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("user not authorized to access project",
                        slog.String("user_id", userID.String()),
                        slog.String("project_id", projectID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this project's organization")
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, GetProjectResponse{
                ID:             project.ID.String(),
                OrganizationID: project.OrganizationID.String(),
                Name:           project.Name,
                CreatedAt:      project.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:      project.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// ListProjectsResponse is the response payload for listing projects
type ProjectSummary struct {
        ID             string `json:"id"`
        OrganizationID string `json:"organization_id"`
        Name           string `json:"name"`
        CreatedAt      string `json:"created_at"`
}

type ListProjectsResponse struct {
        Projects []ProjectSummary `json:"projects"`
}

// ListProjects lists all projects in an organization (organization members only)
func (h *ProjectHandler) ListProjects(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">orgID := c.Param("orgId")
        if orgID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "organization id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse organization ID
        orgUUID, err := parseUUID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization id")
        }</span>

        // Verify user is a member of the organization
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: orgUUID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("user not authorized to list projects in organization",
                        slog.String("user_id", userID.String()),
                        slog.String("org_id", orgID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this organization")
        }</span>

        // Get all projects for the organization
        <span class="cov8" title="1">projects, err := queries.ListProjects(c.Request().Context(), orgUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list projects", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to list projects")
        }</span>

        <span class="cov8" title="1">projectSummaries := make([]ProjectSummary, len(projects))
        for i, project := range projects </span><span class="cov8" title="1">{
                projectSummaries[i] = ProjectSummary{
                        ID:             project.ID.String(),
                        OrganizationID: project.OrganizationID.String(),
                        Name:           project.Name,
                        CreatedAt:      project.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, ListProjectsResponse{
                Projects: projectSummaries,
        })</span>
}

// UpdateProjectRequest is the request payload for updating a project
type UpdateProjectRequest struct {
        Name *string `json:"name,omitempty" validate:"omitempty,min=1,max=255"`
}

// UpdateProjectResponse is the response payload for project update
type UpdateProjectResponse struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        UpdatedAt string `json:"updated_at"`
}

// UpdateProject updates a project (owner/admin only)
func (h *ProjectHandler) UpdateProject(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">projectID := c.Param("id")
        if projectID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "project id is required")
        }</span>

        // Parse request
        <span class="cov8" title="1">var req UpdateProjectRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse project ID
        projectUUID, err := parseUUID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid project id")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "project not found")
        }</span>

        // Verify user is owner or admin of the organization
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to update project",
                        slog.String("user_id", userID.String()),
                        slog.String("project_id", projectID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this project's organization")
        }</span>

        <span class="cov8" title="1">if membership.Role != database.OrganizationRoleOwner &amp;&amp; membership.Role != database.OrganizationRoleAdmin </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can update projects")
        }</span>

        // Update project
        <span class="cov8" title="1">params := database.UpdateProjectParams{
                ID: projectUUID,
        }

        if req.Name != nil </span><span class="cov8" title="1">{
                params.Name = *req.Name
        }</span>

        <span class="cov8" title="1">updatedProject, err := queries.UpdateProject(c.Request().Context(), params)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to update project", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to update project")
        }</span>

        <span class="cov8" title="1">h.logger.Info("project updated", slog.String("project_id", projectID))

        return c.JSON(http.StatusOK, UpdateProjectResponse{
                ID:        updatedProject.ID.String(),
                Name:      updatedProject.Name,
                UpdatedAt: updatedProject.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        })</span>
}

// DeleteProject deletes a project (owner/admin only)
func (h *ProjectHandler) DeleteProject(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">projectID := c.Param("id")
        if projectID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "project id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse project ID
        projectUUID, err := parseUUID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid project id")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "project not found")
        }</span>

        // Verify user is owner or admin of the organization
        <span class="cov8" title="1">membership, err := queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to delete project",
                        slog.String("user_id", userID.String()),
                        slog.String("project_id", projectID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this project's organization")
        }</span>

        <span class="cov8" title="1">if membership.Role != database.OrganizationRoleOwner &amp;&amp; membership.Role != database.OrganizationRoleAdmin </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusForbidden, "only owners and admins can delete projects")
        }</span>

        // Delete project
        <span class="cov8" title="1">err = queries.DeleteProject(c.Request().Context(), projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to delete project", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to delete project")
        }</span>

        <span class="cov8" title="1">h.logger.Info("project deleted", slog.String("project_id", projectID))

        return c.NoContent(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "log/slog"
        "net/http"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

type SafetyCodeHandler struct {
        pool   *pgxpool.Pool
        logger *slog.Logger
}

func NewSafetyCodeHandler(pool *pgxpool.Pool, logger *slog.Logger) *SafetyCodeHandler <span class="cov0" title="0">{
        return &amp;SafetyCodeHandler{
                pool:   pool,
                logger: logger,
        }
}</span>

// CreateSafetyCodeRequest is the request payload for creating a safety code
type CreateSafetyCodeRequest struct {
        Code          string  `json:"code" validate:"required"`
        Description   string  `json:"description" validate:"required"`
        Country       *string `json:"country,omitempty"`
        StateProvince *string `json:"state_province,omitempty"`
}

// SafetyCodeResponse is the response payload for safety code operations
type SafetyCodeResponse struct {
        ID            string  `json:"id"`
        Code          string  `json:"code"`
        Description   string  `json:"description"`
        Country       *string `json:"country,omitempty"`
        StateProvince *string `json:"state_province,omitempty"`
        CreatedAt     string  `json:"created_at"`
        UpdatedAt     string  `json:"updated_at"`
}

// CreateSafetyCode creates a new safety code
func (h *SafetyCodeHandler) CreateSafetyCode(c echo.Context) error <span class="cov0" title="0">{
        // Get authenticated user from session
        _, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov0" title="0">var req CreateSafetyCodeRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Code == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "code is required")
        }</span>
        <span class="cov0" title="0">if req.Description == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "description is required")
        }</span>

        <span class="cov0" title="0">queries := database.New(h.pool)

        // Convert optional fields to pgtype.Text
        var country, stateProvince pgtype.Text
        if req.Country != nil </span><span class="cov0" title="0">{
                country = pgtype.Text{String: *req.Country, Valid: true}
        }</span>
        <span class="cov0" title="0">if req.StateProvince != nil </span><span class="cov0" title="0">{
                stateProvince = pgtype.Text{String: *req.StateProvince, Valid: true}
        }</span>

        // Create safety code
        <span class="cov0" title="0">safetyCode, err := queries.CreateSafetyCode(c.Request().Context(), database.CreateSafetyCodeParams{
                Code:          req.Code,
                Description:   req.Description,
                Country:       country,
                StateProvince: stateProvince,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create safety code", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create safety code")
        }</span>

        <span class="cov0" title="0">h.logger.Info("safety code created",
                slog.String("safety_code_id", safetyCode.ID.String()),
                slog.String("code", safetyCode.Code))

        return c.JSON(http.StatusCreated, safetyCodeToResponse(safetyCode))</span>
}

// GetSafetyCode retrieves a safety code by ID
func (h *SafetyCodeHandler) GetSafetyCode(c echo.Context) error <span class="cov0" title="0">{
        // Get authenticated user from session
        _, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov0" title="0">safetyCodeID := c.Param("id")
        if safetyCodeID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "safety code id is required")
        }</span>

        <span class="cov0" title="0">queries := database.New(h.pool)

        // Parse safety code ID
        safetyCodeUUID, err := parseUUID(safetyCodeID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid safety code id")
        }</span>

        // Get safety code
        <span class="cov0" title="0">safetyCode, err := queries.GetSafetyCode(c.Request().Context(), safetyCodeUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "safety code not found")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, safetyCodeToResponse(safetyCode))</span>
}

// ListSafetyCodesResponse is the response payload for listing safety codes
type ListSafetyCodesResponse struct {
        SafetyCodes []SafetyCodeResponse `json:"safety_codes"`
}

// ListSafetyCodes lists all safety codes with optional filtering
func (h *SafetyCodeHandler) ListSafetyCodes(c echo.Context) error <span class="cov0" title="0">{
        // Get authenticated user from session
        _, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov0" title="0">queries := database.New(h.pool)

        // Check for optional filters
        country := c.QueryParam("country")
        stateProvince := c.QueryParam("state_province")

        var safetyCodes []database.SafetyCode
        var err error

        if country != "" </span><span class="cov0" title="0">{
                // Filter by country
                safetyCodes, err = queries.ListSafetyCodesByCountry(c.Request().Context(), pgtype.Text{String: country, Valid: true})
        }</span> else<span class="cov0" title="0"> if stateProvince != "" </span><span class="cov0" title="0">{
                // Filter by state/province
                safetyCodes, err = queries.ListSafetyCodesByStateProvince(c.Request().Context(), pgtype.Text{String: stateProvince, Valid: true})
        }</span> else<span class="cov0" title="0"> {
                // List all
                safetyCodes, err = queries.ListSafetyCodes(c.Request().Context())
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list safety codes", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to list safety codes")
        }</span>

        <span class="cov0" title="0">responses := make([]SafetyCodeResponse, len(safetyCodes))
        for i, sc := range safetyCodes </span><span class="cov0" title="0">{
                responses[i] = safetyCodeToResponse(sc)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, ListSafetyCodesResponse{
                SafetyCodes: responses,
        })</span>
}

// UpdateSafetyCodeRequest is the request payload for updating a safety code
type UpdateSafetyCodeRequest struct {
        Code          *string `json:"code,omitempty"`
        Description   *string `json:"description,omitempty"`
        Country       *string `json:"country,omitempty"`
        StateProvince *string `json:"state_province,omitempty"`
}

// UpdateSafetyCode updates an existing safety code
func (h *SafetyCodeHandler) UpdateSafetyCode(c echo.Context) error <span class="cov0" title="0">{
        // Get authenticated user from session
        _, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov0" title="0">safetyCodeID := c.Param("id")
        if safetyCodeID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "safety code id is required")
        }</span>

        <span class="cov0" title="0">var req UpdateSafetyCodeRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid request body")
        }</span>

        <span class="cov0" title="0">queries := database.New(h.pool)

        // Parse safety code ID
        safetyCodeUUID, err := parseUUID(safetyCodeID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid safety code id")
        }</span>

        // Get existing safety code to use as base values
        <span class="cov0" title="0">existingSafetyCode, err := queries.GetSafetyCode(c.Request().Context(), safetyCodeUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "safety code not found")
        }</span>

        // Use existing values if not provided in request
        <span class="cov0" title="0">code := existingSafetyCode.Code
        if req.Code != nil </span><span class="cov0" title="0">{
                code = *req.Code
        }</span>

        <span class="cov0" title="0">description := existingSafetyCode.Description
        if req.Description != nil </span><span class="cov0" title="0">{
                description = *req.Description
        }</span>

        <span class="cov0" title="0">country := existingSafetyCode.Country
        if req.Country != nil </span><span class="cov0" title="0">{
                country = pgtype.Text{String: *req.Country, Valid: true}
        }</span>

        <span class="cov0" title="0">stateProvince := existingSafetyCode.StateProvince
        if req.StateProvince != nil </span><span class="cov0" title="0">{
                stateProvince = pgtype.Text{String: *req.StateProvince, Valid: true}
        }</span>

        // Update safety code
        <span class="cov0" title="0">safetyCode, err := queries.UpdateSafetyCode(c.Request().Context(), database.UpdateSafetyCodeParams{
                ID:            safetyCodeUUID,
                Code:          code,
                Description:   description,
                Country:       country,
                StateProvince: stateProvince,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to update safety code", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to update safety code")
        }</span>

        <span class="cov0" title="0">h.logger.Info("safety code updated",
                slog.String("safety_code_id", safetyCode.ID.String()))

        return c.JSON(http.StatusOK, safetyCodeToResponse(safetyCode))</span>
}

// DeleteSafetyCode deletes a safety code by ID
func (h *SafetyCodeHandler) DeleteSafetyCode(c echo.Context) error <span class="cov0" title="0">{
        // Get authenticated user from session
        _, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov0" title="0">safetyCodeID := c.Param("id")
        if safetyCodeID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "safety code id is required")
        }</span>

        <span class="cov0" title="0">queries := database.New(h.pool)

        // Parse safety code ID
        safetyCodeUUID, err := parseUUID(safetyCodeID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid safety code id")
        }</span>

        // Check if safety code exists
        <span class="cov0" title="0">_, err = queries.GetSafetyCode(c.Request().Context(), safetyCodeUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "safety code not found")
        }</span>

        // Delete safety code
        <span class="cov0" title="0">if err := queries.DeleteSafetyCode(c.Request().Context(), safetyCodeUUID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to delete safety code", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to delete safety code")
        }</span>

        <span class="cov0" title="0">h.logger.Info("safety code deleted",
                slog.String("safety_code_id", safetyCodeID))

        return c.NoContent(http.StatusNoContent)</span>
}

// safetyCodeToResponse converts a database safety code to a response
func safetyCodeToResponse(sc database.SafetyCode) SafetyCodeResponse <span class="cov0" title="0">{
        response := SafetyCodeResponse{
                ID:          sc.ID.String(),
                Code:        sc.Code,
                Description: sc.Description,
                CreatedAt:   sc.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:   sc.UpdatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        }

        if sc.Country.Valid </span><span class="cov0" title="0">{
                response.Country = &amp;sc.Country.String
        }</span>
        <span class="cov0" title="0">if sc.StateProvince.Valid </span><span class="cov0" title="0">{
                response.StateProvince = &amp;sc.StateProvince.String
        }</span>

        <span class="cov0" title="0">return response</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "log/slog"
        "net/http"
        "path/filepath"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/dukerupert/aletheia/internal/session"
        "github.com/dukerupert/aletheia/internal/storage"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

type UploadHandler struct {
        storage storage.FileStorage
        pool    *pgxpool.Pool
        logger  *slog.Logger
}

func NewUploadHandler(storage storage.FileStorage, pool *pgxpool.Pool, logger *slog.Logger) *UploadHandler <span class="cov8" title="1">{
        return &amp;UploadHandler{
                storage: storage,
                pool:    pool,
                logger:  logger,
        }
}</span>

// UploadPhotoResponse is the response payload for photo upload
type UploadPhotoResponse struct {
        ID           string  `json:"id"`
        InspectionID string  `json:"inspection_id"`
        StorageURL   string  `json:"storage_url"`
        ThumbnailURL *string `json:"thumbnail_url,omitempty"`
        CreatedAt    string  `json:"created_at"`
}

// UploadImage handles image upload and associates it with an inspection
func (h *UploadHandler) UploadImage(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        // Get inspection_id from form
        <span class="cov8" title="1">inspectionID := c.FormValue("inspection_id")
        if inspectionID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "inspection_id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse inspection ID
        inspectionUUID, err := parseUUID(inspectionID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid inspection_id")
        }</span>

        // Get inspection to verify access
        <span class="cov8" title="1">inspection, err := queries.GetInspection(c.Request().Context(), inspectionUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "inspection not found")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), inspection.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project for inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to verify access")
        }</span>

        // Verify user is a member of the organization that owns this inspection
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("user not authorized to upload photo to inspection",
                        slog.String("user_id", userID.String()),
                        slog.String("inspection_id", inspectionID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this inspection's organization")
        }</span>

        // Get file from form
        <span class="cov8" title="1">file, err := c.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "no file uploaded")
        }</span>

        // Validate file size (e.g., 5MB max)
        <span class="cov8" title="1">if file.Size &gt; 5*1024*1024 </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "file too large (max 5MB)")
        }</span>

        // Validate file type
        <span class="cov8" title="1">contentType := file.Header.Get("Content-Type")
        if contentType != "image/jpeg" &amp;&amp; contentType != "image/png" &amp;&amp; contentType != "image/webp" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid file type (only JPEG, PNG, WebP allowed)")
        }</span>

        // Save file using storage interface
        <span class="cov8" title="1">filename, err := h.storage.Save(c.Request().Context(), file)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to save file", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to save file")
        }</span>

        // Get public URL
        <span class="cov8" title="1">url := h.storage.GetURL(filename)

        // Generate thumbnail
        thumbnailFilename, err := h.storage.GenerateThumbnail(c.Request().Context(), filename)
        var thumbnailURL pgtype.Text
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("failed to generate thumbnail", slog.String("err", err.Error()))
                // Continue without thumbnail - it's not critical
                thumbnailURL = pgtype.Text{Valid: false}
        }</span> else<span class="cov0" title="0"> {
                thumbURL := h.storage.GetURL(thumbnailFilename)
                thumbnailURL = pgtype.Text{String: thumbURL, Valid: true}
        }</span>

        // Create photo record in database
        <span class="cov8" title="1">photo, err := queries.CreatePhoto(c.Request().Context(), database.CreatePhotoParams{
                InspectionID: inspectionUUID,
                StorageUrl:   url,
                ThumbnailUrl: thumbnailURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create photo record", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to create photo record")
        }</span>

        <span class="cov8" title="1">h.logger.Info("photo uploaded",
                slog.String("photo_id", photo.ID.String()),
                slog.String("inspection_id", inspectionID),
                slog.String("user_id", userID.String()))

        // Prepare response with optional thumbnail URL
        response := UploadPhotoResponse{
                ID:           photo.ID.String(),
                InspectionID: photo.InspectionID.String(),
                StorageURL:   photo.StorageUrl,
                CreatedAt:    photo.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        }
        if photo.ThumbnailUrl.Valid </span><span class="cov0" title="0">{
                response.ThumbnailURL = &amp;photo.ThumbnailUrl.String
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, response)</span>
}

// PhotoSummary represents a photo in the list
type PhotoSummary struct {
        ID           string  `json:"id"`
        InspectionID string  `json:"inspection_id"`
        StorageURL   string  `json:"storage_url"`
        ThumbnailURL *string `json:"thumbnail_url,omitempty"`
        CreatedAt    string  `json:"created_at"`
}

// ListPhotosResponse is the response payload for listing photos
type ListPhotosResponse struct {
        Photos []PhotoSummary `json:"photos"`
}

// ListPhotos lists all photos for an inspection
func (h *UploadHandler) ListPhotos(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">inspectionID := c.Param("inspectionId")
        if inspectionID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "inspection id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse inspection ID
        inspectionUUID, err := parseUUID(inspectionID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid inspection id")
        }</span>

        // Get inspection to verify access
        <span class="cov8" title="1">inspection, err := queries.GetInspection(c.Request().Context(), inspectionUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "inspection not found")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), inspection.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project for inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to verify access")
        }</span>

        // Verify user is a member of the organization
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to list photos for inspection",
                        slog.String("user_id", userID.String()),
                        slog.String("inspection_id", inspectionID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this inspection's organization")
        }</span>

        // Get all photos for the inspection
        <span class="cov8" title="1">photos, err := queries.ListPhotos(c.Request().Context(), inspectionUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list photos", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to list photos")
        }</span>

        <span class="cov8" title="1">photoSummaries := make([]PhotoSummary, len(photos))
        for i, photo := range photos </span><span class="cov8" title="1">{
                summary := PhotoSummary{
                        ID:           photo.ID.String(),
                        InspectionID: photo.InspectionID.String(),
                        StorageURL:   photo.StorageUrl,
                        CreatedAt:    photo.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
                }
                if photo.ThumbnailUrl.Valid </span><span class="cov0" title="0">{
                        summary.ThumbnailURL = &amp;photo.ThumbnailUrl.String
                }</span>
                <span class="cov8" title="1">photoSummaries[i] = summary</span>
        }

        <span class="cov8" title="1">return c.JSON(http.StatusOK, ListPhotosResponse{
                Photos: photoSummaries,
        })</span>
}

// GetPhotoResponse is the response payload for photo retrieval
type GetPhotoResponse struct {
        ID           string  `json:"id"`
        InspectionID string  `json:"inspection_id"`
        StorageURL   string  `json:"storage_url"`
        ThumbnailURL *string `json:"thumbnail_url,omitempty"`
        CreatedAt    string  `json:"created_at"`
}

// GetPhoto retrieves a photo by ID
func (h *UploadHandler) GetPhoto(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov8" title="1">photoID := c.Param("id")
        if photoID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "photo id is required")
        }</span>

        <span class="cov8" title="1">queries := database.New(h.pool)

        // Parse photo ID
        photoUUID, err := parseUUID(photoID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid photo id")
        }</span>

        // Get photo
        <span class="cov8" title="1">photo, err := queries.GetPhoto(c.Request().Context(), photoUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "photo not found")
        }</span>

        // Get inspection to verify access
        <span class="cov8" title="1">inspection, err := queries.GetInspection(c.Request().Context(), photo.InspectionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get inspection for photo", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to verify access")
        }</span>

        // Get project to find its organization
        <span class="cov8" title="1">project, err := queries.GetProject(c.Request().Context(), inspection.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project for inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to verify access")
        }</span>

        // Verify user is a member of the organization
        <span class="cov8" title="1">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("user not authorized to access photo",
                        slog.String("user_id", userID.String()),
                        slog.String("photo_id", photoID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this photo's organization")
        }</span>

        <span class="cov8" title="1">response := GetPhotoResponse{
                ID:           photo.ID.String(),
                InspectionID: photo.InspectionID.String(),
                StorageURL:   photo.StorageUrl,
                CreatedAt:    photo.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"),
        }
        if photo.ThumbnailUrl.Valid </span><span class="cov0" title="0">{
                response.ThumbnailURL = &amp;photo.ThumbnailUrl.String
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, response)</span>
}

// DeletePhoto deletes a photo by ID
func (h *UploadHandler) DeletePhoto(c echo.Context) error <span class="cov0" title="0">{
        // Get authenticated user from session
        userID, ok := session.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("failed to get user from session")
                return echo.NewHTTPError(http.StatusUnauthorized, "unauthorized")
        }</span>

        <span class="cov0" title="0">photoID := c.Param("id")
        if photoID == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "photo id is required")
        }</span>

        <span class="cov0" title="0">queries := database.New(h.pool)

        // Parse photo ID
        photoUUID, err := parseUUID(photoID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid photo id")
        }</span>

        // Get photo to verify access and get storage URL
        <span class="cov0" title="0">photo, err := queries.GetPhoto(c.Request().Context(), photoUUID)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "photo not found")
        }</span>

        // Get inspection to verify access
        <span class="cov0" title="0">inspection, err := queries.GetInspection(c.Request().Context(), photo.InspectionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get inspection for photo", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to verify access")
        }</span>

        // Get project to find its organization
        <span class="cov0" title="0">project, err := queries.GetProject(c.Request().Context(), inspection.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get project for inspection", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to verify access")
        }</span>

        // Verify user is a member of the organization
        <span class="cov0" title="0">_, err = queries.GetOrganizationMemberByUserAndOrg(c.Request().Context(), database.GetOrganizationMemberByUserAndOrgParams{
                OrganizationID: project.OrganizationID,
                UserID:         uuidToPgUUID(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("user not authorized to delete photo",
                        slog.String("user_id", userID.String()),
                        slog.String("photo_id", photoID))
                return echo.NewHTTPError(http.StatusForbidden, "you are not a member of this photo's organization")
        }</span>

        // Extract filename from storage URL
        // The URL is like "http://localhost:1323/uploads/filename.jpg" or "https://cdn.example.com/filename.jpg"
        <span class="cov0" title="0">filename := filepath.Base(photo.StorageUrl)

        // Delete file from storage
        if err := h.storage.Delete(c.Request().Context(), filename); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to delete file from storage",
                        slog.String("err", err.Error()),
                        slog.String("photo_id", photoID),
                        slog.String("filename", filename))
                // Continue with database deletion even if storage deletion fails
                // This prevents orphaned database records
        }</span>

        // Delete thumbnail if it exists
        <span class="cov0" title="0">if photo.ThumbnailUrl.Valid </span><span class="cov0" title="0">{
                thumbnailFilename := filepath.Base(photo.ThumbnailUrl.String)
                if err := h.storage.Delete(c.Request().Context(), thumbnailFilename); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("failed to delete thumbnail from storage",
                                slog.String("err", err.Error()),
                                slog.String("photo_id", photoID),
                                slog.String("thumbnail_filename", thumbnailFilename))
                        // Continue even if thumbnail deletion fails
                }</span>
        }

        // Delete photo record from database
        <span class="cov0" title="0">if err := queries.DeletePhoto(c.Request().Context(), photoUUID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to delete photo from database", slog.String("err", err.Error()))
                return echo.NewHTTPError(http.StatusInternalServerError, "failed to delete photo")
        }</span>

        <span class="cov0" title="0">h.logger.Info("photo deleted",
                slog.String("photo_id", photoID),
                slog.String("user_id", userID.String()))

        return c.NoContent(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package session

import (
        "net/http"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"
)

// ContextKey is the type for context keys
type ContextKey string

const (
        // UserIDKey is the context key for user ID
        UserIDKey ContextKey = "user_id"
        // SessionKey is the context key for session data
        SessionKey ContextKey = "session"
)

// SessionMiddleware validates the session cookie and attaches user ID to context
func SessionMiddleware(db *pgxpool.Pool) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Get session token from cookie
                        cookie, err := c.Cookie(SessionCookieName)
                        if err != nil </span><span class="cov0" title="0">{
                                // No cookie found - user not authenticated
                                return echo.NewHTTPError(http.StatusUnauthorized, "authentication required")
                        }</span>

                        // Validate session
                        <span class="cov0" title="0">session, err := GetSession(c.Request().Context(), db, cookie.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                                        // Session not found or expired
                                        return echo.NewHTTPError(http.StatusUnauthorized, "invalid or expired session")
                                }</span>
                                // Database error
                                <span class="cov0" title="0">return echo.NewHTTPError(http.StatusInternalServerError, "session validation failed")</span>
                        }

                        // Attach user ID (convert from pgtype.UUID to uuid.UUID) and session to context
                        <span class="cov0" title="0">c.Set(string(UserIDKey), session.UserID.Bytes)
                        c.Set(string(SessionKey), session)

                        return next(c)</span>
                }
        }
}

// OptionalSessionMiddleware checks for a session but doesn't require it
func OptionalSessionMiddleware(db *pgxpool.Pool) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Get session token from cookie
                        cookie, err := c.Cookie(SessionCookieName)
                        if err != nil </span><span class="cov0" title="0">{
                                // No cookie found - continue without auth
                                return next(c)
                        }</span>

                        // Try to validate session
                        <span class="cov0" title="0">session, err := GetSession(c.Request().Context(), db, cookie.Value)
                        if err == nil </span><span class="cov0" title="0">{
                                // Session valid - attach to context (convert from pgtype.UUID to uuid.UUID)
                                c.Set(string(UserIDKey), session.UserID.Bytes)
                                c.Set(string(SessionKey), session)
                        }</span>
                        // If session is invalid, continue without auth

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// GetUserID retrieves the user ID from the Echo context
func GetUserID(c echo.Context) (uuid.UUID, bool) <span class="cov0" title="0">{
        val := c.Get(string(UserIDKey))
        if val == nil </span><span class="cov0" title="0">{
                return uuid.UUID{}, false
        }</span>

        // The value is stored as [16]byte from pgtype.UUID.Bytes
        <span class="cov0" title="0">if bytes, ok := val.([16]byte); ok </span><span class="cov0" title="0">{
                return uuid.UUID(bytes), true
        }</span>

        // Fallback: try direct uuid.UUID cast
        <span class="cov0" title="0">if userID, ok := val.(uuid.UUID); ok </span><span class="cov0" title="0">{
                return userID, true
        }</span>

        <span class="cov0" title="0">return uuid.UUID{}, false</span>
}

// GetSessionData retrieves the session data from the Echo context
func GetSessionData(c echo.Context) (database.Session, bool) <span class="cov0" title="0">{
        session, ok := c.Get(string(SessionKey)).(database.Session)
        return session, ok
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package session

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "time"

        "github.com/dukerupert/aletheia/internal/database"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jackc/pgx/v5/pgxpool"
)

const (
        // SessionDuration is the default session lifetime
        SessionDuration = 24 * time.Hour
        // SessionCookieName is the name of the session cookie
        SessionCookieName = "session_token"
        // SessionTokenLength is the length of the session token in bytes
        SessionTokenLength = 32
)

// GenerateSessionToken generates a cryptographically secure random session token
func GenerateSessionToken() (string, error) <span class="cov8" title="1">{
        b := make([]byte, SessionTokenLength)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return base64.URLEncoding.EncodeToString(b), nil</span>
}

// CreateSession creates a new session for the given user
func CreateSession(ctx context.Context, db *pgxpool.Pool, userID uuid.UUID, duration time.Duration) (database.Session, error) <span class="cov8" title="1">{
        queries := database.New(db)

        token, err := GenerateSessionToken()
        if err != nil </span><span class="cov0" title="0">{
                return database.Session{}, err
        }</span>

        <span class="cov8" title="1">expiresAt := time.Now().Add(duration)

        session, err := queries.CreateSession(ctx, database.CreateSessionParams{
                UserID: pgtype.UUID{
                        Bytes: userID,
                        Valid: true,
                },
                Token: token,
                ExpiresAt: pgtype.Timestamptz{
                        Time:  expiresAt,
                        Valid: true,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return database.Session{}, err
        }</span>

        <span class="cov8" title="1">return session, nil</span>
}

// GetSession retrieves a session by token if it exists and hasn't expired
func GetSession(ctx context.Context, db *pgxpool.Pool, token string) (database.Session, error) <span class="cov8" title="1">{
        queries := database.New(db)
        return queries.GetSessionByToken(ctx, token)
}</span>

// DestroySession deletes a session by token
func DestroySession(ctx context.Context, db *pgxpool.Pool, token string) error <span class="cov8" title="1">{
        queries := database.New(db)
        return queries.DeleteSession(ctx, token)
}</span>

// DestroyUserSessions deletes all sessions for a given user
func DestroyUserSessions(ctx context.Context, db *pgxpool.Pool, userID uuid.UUID) error <span class="cov8" title="1">{
        queries := database.New(db)
        return queries.DeleteUserSessions(ctx, pgtype.UUID{
                Bytes: userID,
                Valid: true,
        })
}</span>

// CleanupExpiredSessions removes all expired sessions from the database
func CleanupExpiredSessions(ctx context.Context, db *pgxpool.Pool) error <span class="cov8" title="1">{
        queries := database.New(db)
        return queries.DeleteExpiredSessions(ctx)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package storage

import (
        "bytes"
        "context"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "path/filepath"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/google/uuid"
        "mime/multipart"
)

// S3ClientInterface defines the S3 operations we need for storage
type S3ClientInterface interface {
        PutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error)
        GetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error)
        DeleteObject(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)
}

// S3Storage implements FileStorage for AWS S3
type S3Storage struct {
        client  S3ClientInterface
        bucket  string
        region  string
        baseURL string // CloudFront or S3 URL
}

// NewS3Storage creates a new S3 storage instance
func NewS3Storage(client S3ClientInterface, bucket, region, baseURL string) *S3Storage <span class="cov8" title="1">{
        return &amp;S3Storage{
                client:  client,
                bucket:  bucket,
                region:  region,
                baseURL: baseURL,
        }
}</span>

// Save uploads a file to S3
func (s *S3Storage) Save(ctx context.Context, fileHeader *multipart.FileHeader) (string, error) <span class="cov8" title="1">{
        src, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open uploaded file: %w", err)
        }</span>
        <span class="cov8" title="1">defer src.Close()

        // Generate unique filename
        ext := filepath.Ext(fileHeader.Filename)
        filename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), uuid.New().String(), ext)

        // Upload to S3
        _, err = s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                Bucket:      aws.String(s.bucket),
                Key:         aws.String(filename),
                Body:        src,
                ContentType: aws.String(fileHeader.Header.Get("Content-Type")),
        })

        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to upload to S3: %w", err)
        }</span>

        <span class="cov8" title="1">return filename, nil</span>
}

// Delete removes a file from S3
func (s *S3Storage) Delete(ctx context.Context, filename string) error <span class="cov8" title="1">{
        _, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(filename),
        })

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete from S3: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetURL returns the URL to access the file
func (s *S3Storage) GetURL(filename string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", s.baseURL, filename)
}</span>

// GenerateThumbnail creates a thumbnail from the original image stored in S3
func (s *S3Storage) GenerateThumbnail(ctx context.Context, originalFilename string) (string, error) <span class="cov8" title="1">{
        // Download original image from S3
        result, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(originalFilename),
        })
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to download original from S3: %w", err)
        }</span>
        <span class="cov8" title="1">defer result.Body.Close()

        // Decode image
        img, format, err := image.Decode(result.Body)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Resize to thumbnail (300x300 max, maintaining aspect ratio)
        <span class="cov8" title="1">thumbnail := resizeImage(img, 300, 300)

        // Generate thumbnail filename
        ext := filepath.Ext(originalFilename)
        nameWithoutExt := strings.TrimSuffix(originalFilename, ext)
        thumbnailFilename := fmt.Sprintf("%s_thumb%s", nameWithoutExt, ext)

        // Encode thumbnail to buffer
        var buf bytes.Buffer
        var contentType string

        switch format </span>{
        case "jpeg":<span class="cov8" title="1">
                contentType = "image/jpeg"
                err = jpeg.Encode(&amp;buf, thumbnail, &amp;jpeg.Options{Quality: 85})</span>
        case "png":<span class="cov8" title="1">
                contentType = "image/png"
                err = png.Encode(&amp;buf, thumbnail)</span>
        default:<span class="cov0" title="0">
                // Default to JPEG for unknown formats
                contentType = "image/jpeg"
                err = jpeg.Encode(&amp;buf, thumbnail, &amp;jpeg.Options{Quality: 85})</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode thumbnail: %w", err)
        }</span>

        // Upload thumbnail to S3
        <span class="cov8" title="1">_, err = s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                Bucket:      aws.String(s.bucket),
                Key:         aws.String(thumbnailFilename),
                Body:        bytes.NewReader(buf.Bytes()),
                ContentType: aws.String(contentType),
        })

        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to upload thumbnail to S3: %w", err)
        }</span>

        <span class="cov8" title="1">return thumbnailFilename, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package storage

import (
        "context"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "io"
        "log/slog"
        "mime/multipart"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/google/uuid"
)

// FileStorage defines the interface for file storage operations
type FileStorage interface {
        Save(ctx context.Context, file *multipart.FileHeader) (string, error)
        Delete(ctx context.Context, filename string) error
        GetURL(filename string) string
        GenerateThumbnail(ctx context.Context, originalFilename string) (thumbnailFilename string, err error)
}

// StorageConfig holds configuration for storage services
type StorageConfig struct {
        Provider  string // "local" or "s3"
        LocalPath string // Path for local storage
        LocalURL  string // Base URL for local storage
        S3Bucket  string // S3 bucket name
        S3Region  string // S3 region
        S3BaseURL string // CloudFront or S3 base URL
}

// NewFileStorage creates a file storage instance based on the provider configuration
func NewFileStorage(ctx context.Context, logger *slog.Logger, cfg StorageConfig) (FileStorage, error) <span class="cov8" title="1">{
        switch cfg.Provider </span>{
        case "s3":<span class="cov8" title="1">
                // Load AWS configuration
                awsCfg, err := config.LoadDefaultConfig(ctx, config.WithRegion(cfg.S3Region))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load AWS config: %w", err)
                }</span>

                // Create S3 client
                <span class="cov8" title="1">s3Client := s3.NewFromConfig(awsCfg)

                logger.Info("initialized S3 storage",
                        slog.String("bucket", cfg.S3Bucket),
                        slog.String("region", cfg.S3Region),
                )

                return NewS3Storage(s3Client, cfg.S3Bucket, cfg.S3Region, cfg.S3BaseURL), nil</span>

        default:<span class="cov8" title="1"> // "local"
                storage, err := NewLocalStorage(cfg.LocalPath, cfg.LocalURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create local storage: %w", err)
                }</span>

                <span class="cov8" title="1">logger.Info("initialized local storage",
                        slog.String("path", cfg.LocalPath),
                        slog.String("url", cfg.LocalURL),
                )

                return storage, nil</span>
        }
}

// LocalStorage implements FileStorage for local disk storage
type LocalStorage struct {
        basePath string
        baseURL  string
}

// NewLocalStorage creates a new local storage instance
func NewLocalStorage(basePath, baseURL string) (*LocalStorage, error) <span class="cov8" title="1">{
        // Create directory if it doesn't exist
        if err := os.MkdirAll(basePath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create storage directory: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;LocalStorage{
                basePath: basePath,
                baseURL:  baseURL,
        }, nil</span>
}

// Save saves a file to local disk with a unique filename
func (s *LocalStorage) Save(ctx context.Context, fileHeader *multipart.FileHeader) (string, error) <span class="cov8" title="1">{
        // Open uploaded file
        src, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open uploaded file: %w", err)
        }</span>
        <span class="cov8" title="1">defer src.Close()

        // Generate unique filename
        ext := filepath.Ext(fileHeader.Filename)
        filename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), uuid.New().String(), ext)

        // Create destination file
        destPath := filepath.Join(s.basePath, filename)
        dst, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        // Copy file contents
        if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to save file: %w", err)
        }</span>

        <span class="cov8" title="1">return filename, nil</span>
}

// Delete removes a file from local disk
func (s *LocalStorage) Delete(ctx context.Context, filename string) error <span class="cov8" title="1">{
        filePath := filepath.Join(s.basePath, filename)
        if err := os.Remove(filePath); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetURL returns the URL to access the file
func (s *LocalStorage) GetURL(filename string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", s.baseURL, filename)
}</span>

// GenerateThumbnail creates a thumbnail from the original image
func (s *LocalStorage) GenerateThumbnail(ctx context.Context, originalFilename string) (string, error) <span class="cov8" title="1">{
        // Open original file
        originalPath := filepath.Join(s.basePath, originalFilename)
        file, err := os.Open(originalPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to open original file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Decode image
        img, format, err := image.Decode(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Resize to thumbnail (300x300 max, maintaining aspect ratio)
        <span class="cov8" title="1">thumbnail := resizeImage(img, 300, 300)

        // Generate thumbnail filename
        ext := filepath.Ext(originalFilename)
        nameWithoutExt := strings.TrimSuffix(originalFilename, ext)
        thumbnailFilename := fmt.Sprintf("%s_thumb%s", nameWithoutExt, ext)
        thumbnailPath := filepath.Join(s.basePath, thumbnailFilename)

        // Create thumbnail file
        thumbFile, err := os.Create(thumbnailPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create thumbnail file: %w", err)
        }</span>
        <span class="cov8" title="1">defer thumbFile.Close()

        // Encode thumbnail
        switch format </span>{
        case "jpeg":<span class="cov8" title="1">
                err = jpeg.Encode(thumbFile, thumbnail, &amp;jpeg.Options{Quality: 85})</span>
        case "png":<span class="cov8" title="1">
                err = png.Encode(thumbFile, thumbnail)</span>
        default:<span class="cov0" title="0">
                // Default to JPEG for unknown formats
                err = jpeg.Encode(thumbFile, thumbnail, &amp;jpeg.Options{Quality: 85})</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode thumbnail: %w", err)
        }</span>

        <span class="cov8" title="1">return thumbnailFilename, nil</span>
}

// resizeImage resizes an image to fit within maxWidth x maxHeight while maintaining aspect ratio
func resizeImage(img image.Image, maxWidth, maxHeight int) image.Image <span class="cov8" title="1">{
        bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Calculate new dimensions maintaining aspect ratio
        newWidth, newHeight := width, height
        if width &gt; maxWidth || height &gt; maxHeight </span><span class="cov8" title="1">{
                ratio := float64(width) / float64(height)
                if width &gt; height </span><span class="cov8" title="1">{
                        newWidth = maxWidth
                        newHeight = int(float64(maxWidth) / ratio)
                }</span> else<span class="cov8" title="1"> {
                        newHeight = maxHeight
                        newWidth = int(float64(maxHeight) * ratio)
                }</span>
        }

        // If image is already smaller or equal, return original
        <span class="cov8" title="1">if newWidth &gt;= width &amp;&amp; newHeight &gt;= height </span><span class="cov8" title="1">{
                return img
        }</span>

        // Create new image
        <span class="cov8" title="1">dst := image.NewRGBA(image.Rect(0, 0, newWidth, newHeight))

        // Simple nearest-neighbor resizing using the standard library
        xRatio := float64(width) / float64(newWidth)
        yRatio := float64(height) / float64(newHeight)

        for y := 0; y &lt; newHeight; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; newWidth; x++ </span><span class="cov8" title="1">{
                        srcX := int(float64(x) * xRatio)
                        srcY := int(float64(y) * yRatio)
                        dst.Set(x, y, img.At(srcX, srcY))
                }</span>
        }

        <span class="cov8" title="1">return dst</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
